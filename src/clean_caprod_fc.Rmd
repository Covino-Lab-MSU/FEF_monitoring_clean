---
title: "Cap Rod Cleaning - Fool Creek "
author: "Adapted for FEF by LKremer"
date: "`r format(Sys.Date())`"
output:
  html_document:
    theme: journal
    highlight: breezedark
    code_folding: hide
---

This script is used to clean water level data from TruTrak capacitance rods
designed for surface water level measurements.
Cleaning and QA/QC steps include: 

1) removing bad data
2) adjusting data for shifts in logger position
3) converting stage to water depth
4) checking results against manual measurements.

Inputs are capacitance rod raw data (periodically downloaded .csvs) and a manual measurement spreadsheet specific to the site being reviewed

#### Setup
Package and function import from .R script

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(message=F, warning=F, error=F, 
                      comment=NA, cache=T, R.options=list(width=220), 
                      fig.align='center', out.width='75%', fig.asp=.75)

pkgTest <- function(x)
{
  if (x %in% rownames(installed.packages()) == FALSE) {
    install.packages(x, dependencies= TRUE)
  }
  library(x, character.only = TRUE)
}

# Make a vector of the packages you need
neededPackages <- c('tidyverse', 'lubridate', 'xts', 'dygraphs', 'ggrepel','knitr', 'plotly', 'ggpubr') #tools for plot titles 

# For every package in the vector, apply your pkgTest function
for (package in neededPackages){pkgTest(package)}

source('./functions/stageFunctions.R') #load helper functions

#if(!require(devtools)) install.packages("devtools")
#devtools::install_github("kassambara/gg1pubr")
#install.packages("ggpubr")

```

#### Additional functions
Functions that open and concatenate formatted data files


## 2020 {.tabset .tabset-fade}

### Fool1 {.tabset .tabset-fade .tabset-pills}

```{r functions, include=FALSE}

# A universal function to open all caprod data for a 'site' to a list of dataframes
opn_as_dflist <- function(interfiles, year, watershed, site) {
   file_path <- paste(getwd(), interfiles, year, watershed, site, sep='/')
   path_list <- paste(file_path, list.files(file_path), sep= '/')
   data <- lapply(path_list, function(x) {
      dat <- read.table(x, skip = 0, header = TRUE, sep = ",", row.names = NULL, as.is = TRUE)
      # for each item in path list, grab the cap_rod number
      dat$rod_no <- unlist(strsplit(unlist(strsplit(path_list[1], "_"))[8], "[.]"))[1]
      return(dat)
   })
}

# Each year of data has been formatted a bit differently. Rather than reformatting each spreadsheet, 
# a function specific to each year should concatenate the list made by 'opn_as_dflist' 
concat_2020 <- function(data) {
   drops <- c('sample')
   combined.data <- do.call(rbind, data)
   combined.data <- combined.data %>%
     mutate(datetime = lubridate::mdy_hms(datetime)) %>%
     arrange(datetime) %>%
     distinct() %>%
     dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%               rowid_to_column(var='ID') %>%
     select(-one_of(drops))%>%
   return(combined.data)
}
```


Caprod data collection terminated on November 4, 2020 for all Fool sites except for Fool1, which was noted to be pulled by Kelly on October 20, 2020 (ID~16000)

```{r importfc1_20, include=FALSE}

interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc1'

stage_raw <- concat_2020(opn_as_dflist(interfiles, year, watershed, site))

```

Quick raw plot of point data

```{r rawpltfc1_20, fig.align = "center", fig.cap = "Figure 1.1.1: Raw data for Fool 1 (outlet) stage in 2020.", echo=FALSE}

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "Water height point (mm) (mm)")

```

#### Create complete timeseries 

```{r checktimefc1_20, echo=FALSE, results = 'asis'}
#Identifies any missing datetimes from the dataframe:

#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```


```{r checktime2fc1_20, echo=FALSE, results = 'asis'}
cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```

#### Clean Raw Stage

##### 1) Plot temperature for quick checks
 
```{r chktempfc1_20, fig.align = "center", fig.cap = "Figure 1.1.2: Air temperature data captured by the capacitance rod Fool 1 (outlet) in 2020. Rod in Fool 1 was pulled from stream on October 20th.", echo=FALSE}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

# Temperature is variable (dry?) ~ID#16685 rod was pulled 10/20
```

##### 2) Plot raw data with flag if raw level changes by more than 20%.
```{r plantflagsfc1, fig.align = "center", fig.cap = "Figure 1.1.3: Raw stage data from Fool 1 2020 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

##### 3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc1_20}
#fool1
bad_id_fc1_2020 <- c(977:981, 5050:5053, 10953:10957)

#fool1
vert_correction_fc1_2020 <- data.frame(ID = c(0:1), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))
```


```{r badid2fc1_20, include=FALSE}
# correcting functions accept 'bad_id' and 'vert_correction' vectors  
bad_id <- bad_id_fc1_2020
vert_correction <- vert_correction_fc1_2020
```

##### 4) Vertical adjustments
```{r vertcorrectfc1_20}
#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df=stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    filter(ID < 16000) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot4fc1_20, fig.align = "center", fig.cap = "Figure 1.1.4: Stage data from Fool 1 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}

dyStageAdj(df=stage_adj)

```

#### Plot adjusted values only:
```{r plot5fc1_20, fig.align = "center", fig.cap = "Figure 1.1.5: Same as 1.4 but limited to adjusted values only.", echo=FALSE, fig.align = "center"}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

```

#### Manual adjustments: 
```{r plot6fc1_20,, fig.align = "center", fig.cap = "Figure 1.1.6: Adjusted stage data from Fool 1 which includes a manual offset that adjusts all values in the dataframe. "}

manual_offset <- 25
# fc1 = 
# fc2 = 0
stage_adj <- stage_adj%>%
  dplyr::mutate(adj_wtr_ht = adj_wtr_ht + manual_offset)

# Simple df of adjusted values for stacked plot (see below)
simplefc1_20 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()

dyStageAdjonly(df=stage_adj)
```


If no manual measurements accompany dataset (as is the case in 2020), then data can be exported. 
Figures of:
  1. all stage data for a watershed in a given year 
  2. stage data for all years for each site
can help to verify trends and inform adjustments (see below)


#### Export cleaned data
```{r exportfc1_20, include = FALSE}

stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) #adj_wtr_ht will need to be changed to water_depth once manual measurements are considered.
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')

#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))

```


### Fool2 {.tabset .tabset-fade .tabset-pills}

November 4 ~ID no. 18142, but may have been pulled or dry sooner
```{r importfc2, include=FALSE}

interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc2'

stage_raw <- concat_2020(opn_as_dflist(interfiles, year, watershed, site))

```

Quick raw plot of point data

```{r plot1fc2, fig.align = "center", fig.cap = "Figure 1.2.1: Raw data for Fool 2 stage in 2020.", echo=FALSE}

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "Water height point (mm)")

```

#### Create complete timeseries 
Identifies any missing datetimes from the dataframe:
```{r checktimefc2_20, echo=FALSE, results = 'asis'}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```


```{r checktime2fc2, echo=FALSE, results = 'asis'}
cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```

#### Clean Raw Stage

##### 1) Plot temperature for quick checks
 
```{r chktempfc2_20, fig.align = "center", fig.cap = "Figure 1.2.2: Air temperature data captured by the capacitance rod Fool 2 in 2020.", echo=FALSE}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'
```

##### 2) Plot raw data with flag if raw level changes by more than 2%.
```{r plantflagsfc2, fig.align = "center", fig.cap = "Figure 1.2.3: Raw stage data from Fool 2 2020 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}

#Raw stage plot
DyRawStage(df=stage_raw, threshold = 0.2, flag='TRUE')
```

##### 3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc2_20}
#fool2
bad_id_fc2_2020 <- c(4953:4960, 11952:12730)

vert_correction_fc2_2020 <- data.frame(ID = c(1:2), offset=c(0.00)) %>%
  mutate(cumOffset = cumsum(offset))
```


```{r badid2fc2_20, include=FALSE}
bad_id <- bad_id_fc2_2020
vert_correction <- vert_correction_fc2_2020
```

##### 4) Vertical adjustments
```{r vertcorrectfc2_20}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df=stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    #filter(ID < 12730) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot4fc2_20, fig.align = "center", fig.cap = "Figure 1.2.4: Stage data from Fool 2 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}

dyStageAdj(df=stage_adj)

```

#### Plot adjusted values only:
```{r plot5fc2_20, fig.align = "center", fig.cap = "Figure 1.2.5: Same as 2.4 but limited to adjusted values only.", echo=FALSE}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)
```

#### Manual adjustments: 
```{r plot6fc2_20,, fig.align = "center", fig.cap = "Figure 1.2.6: Adjusted stage data from Fool 2 which includes a manual offset that adjusts all values in the dataframe. "}

manual_offset <- -70

stage_adj <- stage_adj%>%
  dplyr::mutate(adj_wtr_ht = adj_wtr_ht + manual_offset)

# Simple df of adjusted values for stacked plot (see below)
simplefc2_20 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()

dyStageAdjonly(df=stage_adj)

```

If no manual measurements accompany dataset (as is the case in 2020), then data can be exported.
Figures of:
1. all stage data for a watershed in a given year 
2. stage data for all years for each site
can help to verify trends and inform adjustments (see below)

#### Export cleaned data
```{r exportfc2_20}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) #adj_wtr_ht will need to be changed to water_depth once manual measurements are considered.
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')

#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```


### Fool3 {.tabset .tabset-fade .tabset-pills}

```{r importfc3_20, include=FALSE}

interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc3'

stage_raw <- concat_2020(opn_as_dflist(interfiles, year, watershed, site))

```

Quick raw plot of point data

```{r plot1fc3_20, fig.align = "center", fig.cap = "Figure 1.3.1: Raw data for Fool 3 stage in 2020.", echo=FALSE}

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "Water height point (mm)")

```

#### Create complete timeseries 
Identifies any missing datetimes from the dataframe:
```{r checktimefc3_20, echo=FALSE, results = 'asis'}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```


```{r checktime2fc3_20, echo=FALSE, results = 'asis'}
cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```

#### Clean Raw Stage

##### 1) Plot temperature for quick checks
```{r chktempfc3_20, fig.align = "center", fig.cap = "Figure 1.3.2: Air temperature data captured by the capacitance rod Fool 3 in 2020.", echo=FALSE}

DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'
```

##### 2) Plot raw data with flag if raw level changes by more than 2%.
```{r plantflagsfc3_20, fig.align = "center", fig.cap = "Figure 1.3.3: Raw stage data from Fool 3 2020 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

##### 3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc3_20}
#fool3
bad_id_fc3_2020 <- c(5182:5186)

vert_correction_f3_2020 <- data.frame(ID = c(7860:12965), offset=c(20)) %>%
  mutate(cumOffset = offset)
```


```{r badid2fc3_20, include=FALSE}
bad_id <- bad_id_fc3_2020
vert_correction<- vert_correction_f3_2020
```

##### 4) Vertical adjustments
```{r vertcorrectfc3_20}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df=stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    filter(ID < 12210) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot4fc3_20, fig.align = "center", fig.cap = "Figure 1.3.4: Stage data from Fool 3 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}

dyStageAdj(df=stage_adj)

```

#### Plot adjusted values only:
```{r plot5fc3_20, fig.align = "center", fig.cap = "Figure 1.3.5: Same as 3.4 but limited to adjusted values only.", echo=FALSE}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)
```


#### Manual adjustments: 
```{r plot6fc3_20,, fig.align = "center", fig.cap = "Figure 1.3.6: Adjusted stage data from Fool 3 which includes a manual offset that adjusts all values in the dataframe. "}

manual_offset <- -25

stage_adj <- stage_adj%>%
  dplyr::mutate(adj_wtr_ht = adj_wtr_ht + manual_offset)

# Simple df of adjusted values for stacked plot (see below)
simplefc3_20 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()

dyStageAdjonly(df=stage_adj)
```

If no manual measurements accompany dataset (as is the case in 2020), 
then data can be exported.
Figures of:
1. all stage data for a watershed in a given year 
2. stage data for all years for each site
can help to verify trends and inform adjustments (see below)

#### Export cleaned data
```{r exportfc3_20}

stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) #adj_wtr_ht will need to be changed to water_depth once manual measurements are considered.
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')

#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```


### Fool4 {.tabset .tabset-fade .tabset-pills}

```{r importfc4_20, include=FALSE}

interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc4'

stage_raw <- concat_2020(opn_as_dflist(interfiles, year, watershed, site))

```

Quick plot of raw data
```{r plot1fc4_20, fig.align = "center", fig.cap = "Figure 1.4.1: Raw data for Fool 4 stage in 2020.", echo=FALSE}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "Water height point (mm)")
  
```

#### Create complete timeseries 
Identifies any missing datetimes from the dataframe
```{r checktimefc4_20, echo=FALSE, results = 'asis'}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```


```{r checktime2fc4_20, echo=FALSE, results = 'asis'}
cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```

###Clean Raw Stage

##### 1) Plot temperature for quick checks
 
```{r chktempfc4_20, fig.align = "center", fig.cap = "Figure 1.4.2: Air temperature data captured by the capacitance rod Fool 4 in 2020.", echo=FALSE}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'
```

##### 2) Plot raw data with flag if raw level changes by more than 2%.
```{r plantflagsfc4_20, fig.align = "center", fig.cap = "Figure 1.4.3: Raw stage data from Fool 4 2020 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}


#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

##### 3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc4_20}
#fool4
bad_id_fc4_2020 <- c(5182:5186, 5909:5912)

vert_correction_f4_2020 <- data.frame(ID = c(7860:12965), offset=c(0.00)) %>%
  mutate(cumOffset = cumsum(offset))
```


```{r badid2fc4_20, include=FALSE}
bad_id <- bad_id_fc4_2020
vert_correction<- vert_correction_f4_2020
```

##### 4) Vertical adjustments
```{r vertcorrectfc4_20}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df=stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    filter(ID < 12966) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot4fc4_20, fig.align = "center", fig.cap = "Figure 1.4.4: Stage data from Fool 4 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}

#plot adjusted stage
dyStageAdj(df=stage_adj)

```

#### Plot adjusted values only:
```{r plot5fc4_20, fig.align = "center", fig.cap = "Figure 1.4.5: Same as 4.5 but limited to adjusted values only.", echo=FALSE}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple plot of adjusted values for stacking (see below)
simplefc4_20 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```

If no manual measurements accompany dataset (as is the case in 2020), then data can be exported.
Figures of:
1. all stage data for a watershed in a given year 
2. stage data for all years for each site
can help to verify trends and inform adjustments (see below)

#### Export cleaned data
```{r exportfc4_20}

stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) #adj_wtr_ht will need to be changed to water_depth once manual measurements are considered.
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')

#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```

## 2020 Site stack
Stack sites in a plot to 
1. check interannual variation
2. verify/modify vertical corrections

```{r}
allfc <- rbind(simplefc1_20,simplefc2_20) 
allfc <- rbind(allfc,simplefc3_20) 
allfc <- rbind(allfc,simplefc4_20)

sitestack_20 <- ggplot(allfc, aes(x = datetime, y = adj_wtr_ht, color = site)) +  
  geom_line()

sitestack_20
```


## 2021 {.tabset}

All Fool data terminated 9/29/21 
```{r functions21, include=FALSE}
concat_2021 <- function(data) {
   drops <- c("formatted_datetime", 'sample')
   combined.data <- do.call(rbind, data)
   combined.data <- combined.data %>%
     mutate(datetime = lubridate::mdy_hm(datetime)) %>%
     arrange(datetime) %>%
     dplyr::distinct() %>%
     dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%      rowid_to_column(var='ID') %>%
     select(-one_of(drops))
   return(combined.data)
}
```

### Fool1 {.tabset .tabset-fade .tabset-pills}

```{r importfc1_21, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2021
watershed<- 'fool'
site <- 'fc1'

stage_raw <- concat_2021(opn_as_dflist(interfiles, year, watershed, site)) %>%
  drop_na()

```

Quick raw plot of point data
```{r plot1fc1_21, fig.align = "center", fig.cap = "Figure 2.1.1: Raw data for Fool 1 stage in 2020.", echo=FALSE}

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "Water height point (mm)")

```

#### Create complete timeseries 
Identifies any missing datetimes from the dataframe
```{r checktimefc1_21, echo=FALSE, results = 'asis'}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```


```{r checktime2fc1_21, echo=FALSE, results = 'asis'}
cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```

#### Clean Raw Stage

##### 1) Plot temperature for quick checks
 
```{r chktempfc1_21, fig.align = "center", fig.cap = "Figure 2.1.2: Air temperature data captured by the capacitance rod Fool 1 (outlet) in 2021.", echo=FALSE}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

```

##### 2) Plot raw data with flag if raw level changes by more than 2%.
```{r plantflagsfc1_2021, fig.align = "center", fig.cap = "Figure 2.1.3: Raw stage data from Fool 1 2021 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

##### 3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc1_21}
#fool2
bad_id_fc1_2021 <-  c(0:289, 1895:1898, 2910:2914, 4053:4056, 4944:4948, 8099:8103, 14991:14994, 18129:18132)

#fool2
vert_correction_fc1_2021<- data.frame(ID = c(8175:8186), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))
```


```{r badid2fc1_21, include=FALSE}  
bad_id <- bad_id_fc1_2021
vert_correction <- vert_correction_fc1_2021
```

##### 4) Vertical adjustments
```{r vertcorrectfc1_21}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df=stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    filter(ID < 12210) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot4fc1_21, fig.align = "center", fig.cap = "Figure 2.1.4: Stage data from Fool 1 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}

dyStageAdj(df=stage_adj)

```

Plot adjusted values only:
```{r plot5fc1_21, fig.align = "center", fig.cap = "Figure 2.1.5: Same as 1.4 but limited to adjusted values only.", echo=FALSE}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc1_21 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```


#### Check manual measurements
```{r importmanualfc1_21}
# load manual measurements
interfiles <- 'formatted_data/manual_measurements'
file_path <- paste(getwd(),interfiles,paste(year, '/', site,'.csv', sep = ""), sep='/')

manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)

manMeas<- read.csv(file_path)%>%
      #timezone set to MST, change if loggers used MDT/MST
      mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
      mutate(water_depth = dep_to_bed-dep_to_water)%>%
      mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc1_21}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
stat_to_bed <- manMeas%>%
  summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
  pull(mean_dep_to_bed)

manMeas_fil <- manMeas %>%
      #filter(watershed == watershed)%>%
      #filter(site == site)%>%
      dplyr::rename(., wtr_depth_not_static = water_depth) %>%
      mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
### 10 to convert mm to cm

depth_offset <- manMeas_fil %>%
  slice_min(datetime)%>%
  left_join(stage_adj %>%
              dplyr::select(datetime, adj_wtr_ht))%>%
  mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
  pull(depth_offset)
```

#### Manual adjustments: 
```{r plot6fc1_21,, fig.align = "center", fig.cap = "Figure 2.1.6: Adjusted stage data from Fool 1 which includes a manual offset that adjusts all values in the dataframe."}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
manual_offset <- 5
# fc1 = 
# fc2 = 0
stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)

stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

#### Compare cleaned water level to manual measurements
```{r plot7fc1_21, fig.align = "center"}
#plot difference between measured water depth and manual depth measurement
stage_adj <- as.data.frame(stage_adj)
stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
      mutate(diff = man_wtr_dep_static-wtr_depth)

ggplot(stageAdj.man, aes(datetime, diff))+
  geom_point(size=3)+
  theme_minimal()
```


```{r plot8fc1_21, fig.align = "center", fig.cap = "Figure 2.1.7: Adjusted stage data with manual measurements (points)"}
#plot water level time series with manual measurements as points
stage_check_plot<- stage_adj%>%
  dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
  ggplot(aes(datetime,wtr_depth))+
    geom_line()+
    geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')

ggplotly(stage_check_plot)
```

#### Export cleaned data
```{r savefc1_21}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))

```

### Fool2 {.tabset .tabset-fade .tabset-pills}

```{r importfc2_21, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2021
watershed<- 'fool'
site <- 'fc2'

stage_raw <- concat_2021(opn_as_dflist(interfiles, year, watershed, site)) 

```

Quick raw plot of point data
```{r plot1fc2_21, fig.align = "center", fig.cap = "Figure 2.2.1: Raw data for Fool 2 stage in 2021.", echo=FALSE}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line()

```

#### Create complete timeseries to identify any missing datetimes from the dataframe
```{r checktimefc2_21, echo=FALSE, results = 'asis'}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```


```{r checktime2fc2_21, echo=FALSE, results = 'asis'}
cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```

#### Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc2_21, fig.align = "center", fig.cap = "Figure 2.2.2: Air temperature data captured by the capacitance rod Fool 2 in 2021.", echo=FALSE}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

```
Looks like air temp until ~ID273

2) Plot raw data with flag if raw level changes by more than 2%.

```{r plantflagsfc2_2021, fig.align = "center", fig.cap = "Figure 2.2.3: Raw stage data from Fool 2 2021 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc2_21}
#fool2
bad_id_fc2_2021 <- c(0:219,1174:1178, 4288:4293, 11104:11107, 16256:16257)

#fool2
vert_correction_fc1_2021 <- data.frame(ID = c(4262:16257), offset=c(-.0015))%>%
  mutate(cumOffset = cumsum(offset))
```


```{r badid2fc2_21, include=FALSE}
bad_id <- bad_id_fc2_2021
vert_correction <- vert_correction_fc1_2021
```

4) Vertical adjustments
```{r vertcorrectfc2_21}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw,maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot4fc2_21, fig.align = "center", fig.cap = "Figure 2.2.4: Stage data from Fool 2 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}

dyStageAdj(df=stage_adj)

```

Plot adjusted values only:
```{r plot5fc2_21, fig.align = "center", fig.cap = "Figure 2.2.5: Same as 2.2.4 but limited to adjusted values only.", echo=FALSE}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc2_21 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```


#### Check manual measurements
```{r importmanualfc2_21}
# load manual measurements
interfiles <- 'formatted_data/manual_measurements'
file_path <- paste(getwd(),interfiles,paste(year, '/', site,'.csv', sep = ""), sep='/')

manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)

manMeas<- read.csv(file_path)%>%
      #timezone set to MST, change if loggers used MDT/MST
      mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
      mutate(water_depth = dep_to_bed-dep_to_water)%>%
      mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc2_21}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
stat_to_bed <- manMeas%>%
  summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
  pull(mean_dep_to_bed)

manMeas_fil <- manMeas %>%
      #filter(watershed == watershed)%>%
      #filter(site == site)%>%
      dplyr::rename(., wtr_depth_not_static = water_depth) %>%
      mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
### 10 to convert mm to cm

depth_offset <- manMeas_fil %>%
  slice_min(datetime)%>%
  left_join(stage_adj %>%
              dplyr::select(datetime, adj_wtr_ht))%>%
  mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
  pull(depth_offset)
```


Manual adjustments: 
```{r plot6fc2_21,, fig.align = "center", fig.cap = "Figure 2.2.6: Adjusted stage data from Fool 2 which includes a manual offset that adjusts all values in the dataframe. "}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
manual_offset <- 0
# fc1 = 
# fc2 = 0
stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)

stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

#### Compare cleaned water level to manual measurements
```{r plot7fc2_21, fig.align = "center"}
#plot difference between measured water depth and manual depth measurement
stage_adj <- as.data.frame(stage_adj)
stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
      mutate(diff = man_wtr_dep_static-wtr_depth)

ggplot(stageAdj.man, aes(datetime, diff))+
  geom_point(size=3)+
  theme_minimal()
```


```{r plot8fc2_21, fig.align = "center", fig.cap = "Figure 2.2.7: Adjusted stage data with manual measurements (points)"}
#plot water level time series with manual measurements as points
stage_check_plot<- stage_adj%>%
  dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
  ggplot(aes(datetime,wtr_depth))+
    geom_line()+
    geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')

ggplotly(stage_check_plot)
```

#### Export cleaned data
```{r savefc2_21}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))

```


### Fool3


```{r importfc3_21, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2021
watershed<- 'fool'
site <- 'fc3'

stage_raw <- concat_2021(opn_as_dflist(interfiles, year, watershed, site)) 

```

Quick raw plot of point data
```{r plot1fc3_21, fig.align = "center", fig.cap = 'Figure 2.3.1: Raw data for Fool3 stage in 2021.', echo=FALSE}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line()

```

#### Create complete timeseries 
Identifies any missing datetimes from the dataframe

```{r checktimefc3_21, echo=FALSE, results = 'asis'}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```


```{r checktime2fc3_21, echo=FALSE, results = 'asis'}
cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```

#### Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc3_21, fig.align = "center", fig.cap = "Figure 2.3.2: Air temperature data captured by the capacitance rod Fool 3 in 2021.", echo=FALSE}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

```
Looks like air temp until ~ID273

2) Plot raw data with flag if raw level changes by more than 2%.

```{r plantflagsfc3_21, fig.align = "center", fig.cap = "Figure 2.3.3: Raw stage data from Fool 3 2021 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc3_21}
#fool3
bad_id_fc3_2021 <- c(0:5,1166:1170, 4283:4287, 10091:10095)

#fool3
vert_correction_fc3_2021<- data.frame(ID = c(5714:14203), offset=c(-0.0033))%>%
  mutate(cumOffset = cumsum(offset))
```


```{r badid2fc3_21, include=FALSE}  
bad_id <- bad_id_fc3_2021

vert_correction <- vert_correction_fc3_2021

```

4) Vertical adjustments
```{r vertcorrect_fc3_21}
stage_adj<- AdjStage(df= stage_raw, maxgap=8) %>%
    filter(ID < 14229) %>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))


```

#### Plot adjusted stage
```{r plot4fc3_21, fig.align = "center", fig.cap = "Figure 2.3.4: Stage data from Fool 3 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}

dyStageAdj(df=stage_adj)

```

Plot adjusted values only:
```{r plot5fc3_21, fig.align = "center", fig.cap = "Figure 2.3.5: Same as 3.4 but limited to adjusted values only.", echo=FALSE}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(-50, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc3_21 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```


#### Check manual measurements
```{r importmanualfc3_21}
# load manual measurements
interfiles <- 'formatted_data/manual_measurements'
file_path <- paste(getwd(),interfiles,paste(year, '/', site,'.csv', sep = ""), sep='/')

manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)

manMeas<- read.csv(file_path)%>%
      #timezone set to MST, change if loggers used MDT/MST
      mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
      mutate(water_depth = dep_to_bed-dep_to_water)%>%
      mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc3_21}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
stat_to_bed <- manMeas%>%
  summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
  pull(mean_dep_to_bed)

manMeas_fil <- manMeas %>%
      #filter(watershed == watershed)%>%
      #filter(site == site)%>%
      dplyr::rename(., wtr_depth_not_static = water_depth) %>%
      mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
### 10 to convert mm to cm

depth_offset <- manMeas_fil %>%
  slice_min(datetime)%>%
  left_join(stage_adj %>%
              dplyr::select(datetime, adj_wtr_ht))%>%
  mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
  pull(depth_offset)
```


Manual adjustments: 
```{r plot6fc3_21,, fig.align = "center", fig.cap = "Figure 2.3.6: Adjusted stage data from Fool 3 which includes a manual offset that adjusts all values in the dataframe. "}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
#stage_adj[14231:16228,]$adj_wtr_ht <- stage_adj[14231:16228,]$adj_wtr_ht + 35

manual_offset <- 0
# fc1 = 
# fc2 = 0
stage_adj <- stage_adj %>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)

stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

#### Compare cleaned water level to manual measurements
```{r plot7fc3_21, fig.align = "center"}
#plot difference between measured water depth and manual depth measurement
stage_adj <- as.data.frame(stage_adj)
stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
      mutate(diff = man_wtr_dep_static-wtr_depth)

ggplot(stageAdj.man, aes(datetime, diff))+
  geom_point(size=3)+
  theme_minimal()
```


```{r plot8fc3_21, fig.align = "center", fig.cap = "Figure 2.3.7: Adjusted stage data with manual measurements (points)"}
#plot water level time series with manual measurements as points
stage_check_plot<- stage_adj%>%
  dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
  ggplot(aes(datetime,wtr_depth))+
    geom_line()+
    geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')

ggplotly(stage_check_plot)
```

#### Export cleaned data
```{r savefc3_21}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```


### Fool4


```{r importfc4_21, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2021
watershed<- 'fool'
site <- 'fc4'

stage_raw <- concat_2021(opn_as_dflist(interfiles, year, watershed, site)) 
```

Quick raw plot of point data
```{r plot1fc4_21, fig.align = 'center', fig.cap = "Figure 2.4.1: Raw data for Fool 4 stage in 2021.", echo=FALSE}

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line()

```


#### Create complete timeseries to identify any missing datetimes from the dataframe

```{r checktimefc4_21, echo=FALSE, results = 'asis'}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```


```{r checktime2fc4_21, echo=FALSE, results = 'asis'}
cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```


#### Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc4_21, fig.align = "center", fig.cap = "Figure 2.4.2: Air temperature data captured by the capacitance rod Fool 4 in 2021.", echo=FALSE}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

```

2) Plot raw data with flag if raw level changes by more than 2%.

```{r plantflagsfc4_21, fig.align = "center", fig.cap = "Figure 2.4.3: Raw stage data from Fool 4 2021 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot

```{r badidfc4_21}
#fool3
bad_id_fc4_2021 <- c(3900:3905, 8965:8969, 10967:10971)

#fool3
vert_correction_fc4_2021<- data.frame(ID = c(8175:8176), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))
```


```{r badid2fc4_21, include=FALSE}  
bad_id <- bad_id_fc4_2021

vert_correction <- vert_correction_fc4_2021

```


```{r vertcorrectfc4_21}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw, maxgap=8)%>%
    filter(ID > 3) %>% # beginning of stream data
    filter(ID < 15100) %>% # end of stream data
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

```

#### Plot adjusted stage
```{r plot4fc4_21, fig.align = "center", fig.cap = "Figure 2.4.4: Stage data from Fool 4 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}

dyStageAdj(df=stage_adj)

```

look at the adjusted values only
```{r plot3fc4_21, fig.align = "center", fig.cap = "Figure 2.4.5: Same as 2.4.4 but limited to adjusted values only.", echo=FALSE}
dyStageAdjonly<- function(df = stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc4_21 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```

#### Check manual measurements
```{r importmanualfc4_21}
# # load manual measurements
interfiles <- 'formatted_data/manual_measurements'
file_path <- paste(getwd(),interfiles,paste(year, '/', site,'.csv', sep = ""), sep='/')

manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)

manMeas<- read.csv(file_path)%>%
      #timezone set to MST, change if loggers used MDT/MST
      mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'10 minutes'))%>%
      mutate(water_depth = dep_to_bed-dep_to_water)%>%
      mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc4_21}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
stat_to_bed <- manMeas%>%
  summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
  pull(mean_dep_to_bed)

manMeas_fil <- manMeas %>%
      #filter(watershed == watershed)%>%
      #filter(site == site)%>%
      dplyr::rename(., wtr_depth_not_static = water_depth) %>%
      mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
### 10 to convert mm to cm

depth_offset <- manMeas_fil %>%
  slice_min(datetime)%>%
  left_join(stage_adj %>%
              dplyr::select(datetime, adj_wtr_ht))%>%
  mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
  pull(depth_offset)

depth_offset
```


Manual adjustments: 
```{r plot6fc4_21,, fig.align = "center", fig.cap = "Figure 2.4.6: Adjusted stage data from Fool 4 which includes a manual offset that adjusts all values in the dataframe. "}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
manual_offset <- 0
# fc1 =
# fc2 = 0
stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)

stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

#### Compare cleaned water level to manual measurements
```{r plot7fc4_21, fig.align = "center"}
#plot difference between measured water depth and manual depth measurement
stage_adj <- as.data.frame(stage_adj)
stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
      mutate(diff = man_wtr_dep_static-wtr_depth)

ggplot(stageAdj.man, aes(datetime, diff))+
  geom_point(size=3)+
  theme_minimal()
```


```{r plot8fc4_21, fig.align = "center", fig.cap = "Figure 2.4.7: Adjusted stage data with manual measurements (points)"}
#plot water level time series with manual measurements as points
stage_check_plot<- stage_adj %>%
  dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
  ggplot(aes(datetime,wtr_depth))+
    geom_line()+
    geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')

ggplotly(stage_check_plot)
```

#### Export cleaned data
```{r savefc4_21}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```


## 2021 Site stack
Stack sites in a plot to 
1. check interannual variation
2. verify/modify vertical corrections

```{r}
allfc <- rbind(simplefc1_21,simplefc2_21) 
allfc <- rbind(allfc,simplefc3_21) 
allfc <- rbind(allfc,simplefc4_21)

sitestack_21 <- ggplot(allfc, aes(x = datetime, y = adj_wtr_ht, color = site)) +
  geom_line()

sitestack_21
```


## 2022 {.tabset}
### Fool1 

Data termination date: 
```{r functions22, include=FALSE}

concat_2022 <- function(data) {
  drops <- c('sample')
  combined.data <- do.call(rbind, data)
  combined.data <- combined.data %>%
    mutate(datetime = lubridate::mdy_hm(datetime)) %>%
    arrange(datetime) %>%
    dplyr::distinct() %>%
    dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%      rowid_to_column(var='ID') %>%
  select(-one_of(drops))
   return(combined.data)
}

```

```{r importfc1_22, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2022
watershed<- 'fool'
site <- 'fc1'

stage_raw <- concat_2022(opn_as_dflist(interfiles, year, watershed, site))

stage_raw <- stage_raw%>%
  set_names(c('ID','datetime','water_temp', 'wtr_ht_pt', 'wtr_ht_avg', 'rod_no'))

```

Quick raw plot of point data
```{r plot1fc1_22, fig.align = "center", fig.cap = 'Figure 3.1.1: Raw data for Fool 1 stage in 2022.', echo=FALSE}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+geom_line()

```


#### Create complete timeseries to identify any missing datetimes from the dataframe
```{r checktimefc1_22, echo=FALSE, results = 'asis'}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```

```{r checktime2fc1_22, echo=FALSE, results = 'asis'}
cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```

#### Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc1_22, fig.align = "center", fig.cap = "Figure 3.1.2: Air temperature data captured by the capacitance rod Fool 1 in 2022.", echo=FALSE}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'
```

2) Plot raw data with flag if raw level changes by more than 2%.
```{r plantflagsfc1_22, fig.align = "center", fig.cap = "Figure 3.1.3: Raw stage data from Fool 1 2022 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc1_22}
#fool2
bad_id_fc1_2022 <-  c(3626:3916, 8044:8066, 11089:11093, 12236:12239, 12984:12992, 13987:13991, 16021:16027, 17128:17132, 18139:18143)

#fool2
vert_correction_fc1_2022<- data.frame(ID = c(8175:8186), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))
```


```{r badid2fc1_22, include=FALSE}  
bad_id <- bad_id_fc1_2022
vert_correction <- vert_correction_fc1_2022
```

4) Vertical adjustments
```{r vertcorrectfc1_22}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df=stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    filter(ID < 22222) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot4fc1_22, fig.align = "center", fig.cap = "Figure 3.1.4: Stage data from Fool 1 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}


dyStageAdj(df=stage_adj)

```

Plot adjusted values only:
```{r plot5fc1_22, fig.align = "center", fig.cap = "Figure 3.1.5: Same as 3.1.4 but limited to adjusted values only.", echo=FALSE}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc1_22 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```


#### Check manual measurements
```{r importmanualfc1_22}
# load manual measurements
# interfiles <- 'formatted_data/manual_measurements'
# file_path <- paste(getwd(),interfiles, paste(site,'.csv', sep = ""), sep='/')
# 
# manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)
# 
# manMeas<- read.csv(file_path)%>%
#       #timezone set to MST, change if loggers used MDT/MST
#       mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
#       mutate(water_depth = dep_to_bed-dep_to_water)%>%
#       mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc1_22}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
# stat_to_bed <- manMeas%>%
#   summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
#   pull(mean_dep_to_bed)
# 
# manMeas_fil <- manMeas %>%
#       #filter(watershed == watershed)%>%
#       #filter(site == site)%>%
#       dplyr::rename(., wtr_depth_not_static = water_depth) %>%
#       mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
# ### 10 to convert mm to cm
# 
# depth_offset <- manMeas_fil %>%
#   slice_min(datetime)%>%
#   left_join(stage_adj %>%
#               dplyr::select(datetime, adj_wtr_ht))%>%
#   mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
#   pull(depth_offset)
```


Manual adjustments: 
```{r plot6fc1_22,, fig.align = "center", fig.cap = "Figure 3.1.6: Adjusted stage data from Fool 1 which includes a manual offset that adjusts all values in the dataframe. "}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
# manual_offset <- 5
# # fc1 = 
# # fc2 = 0
# stage_adj <- stage_adj%>%
#   mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)
# 
# stage_adj <- stage_adj%>%
#   mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

#### Compare cleaned water level to manual measurements
```{r plot7fc1_22, fig.align = "center"}
#plot difference between measured water depth and manual depth measurement
# stage_adj <- as.data.frame(stage_adj)
# stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
#       mutate(diff = man_wtr_dep_static-wtr_depth)
# 
# ggplot(stageAdj.man, aes(datetime, diff))+
#   geom_point(size=3)+
#   theme_minimal()
```


```{r plot8fc1_22, fig.align = "center", fig.cap = "Figure 3.1.7: Adjusted stage data with manual measurements (points)"}
#plot water level time series with manual measurements as points
# stage_check_plot<- stage_adj%>%
#   dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
#   ggplot(aes(datetime,adj_wtr_ht))+
#   ggplot(aes(datetime,wtr_depth))+
#     geom_line()+
#     geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')
# 
# ggplotly(stage_check_plot)
```

#### Export cleaned data
```{r savefc1_22}
#stage_final <- stage_adj %>%
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
        #dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))

```

### Fool2


```{r importfc2_22, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2022
watershed<- 'fool'
site <- 'fc2'

stage_raw <- concat_2022(opn_as_dflist(interfiles, year, watershed, site)) 

```

Quick raw plot of point data
```{r plot1fc2_22, fig.align = "center", fig.cap = 'Figure 3.2.1: Raw data for Fool 2 stage in 2022.', echo=FALSE}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line()

```

#### Create complete timeseries to identify any missing datetimes from the dataframe
```{r checktimefc2_22, echo=FALSE, results = 'asis'}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```

```{r checktime2fc2_22, echo=FALSE, results = 'asis'}
cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```

#### Clean Raw Stage

##### 1) Plot temperature for quick checks
 
```{r chktempfc2_22, fig.align = "center", fig.cap = "Figure 3.2.2: Air temperature data captured by the capacitance rod Fool 2 in 2022.", echo=FALSE}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

```
Looks like air temp until ~ID2021

##### 2) Plot raw data with flag if raw level changes by more than 2%.

```{r plantflagsfc2_22, fig.align = "center", fig.cap = "Figure 3.2.3: Raw stage data from Fool 2 2022 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

##### 3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc2_22}
#fool2
bad_id_fc2_2022 <- c(8421:8424, 10839:10844, 12867:12872)

#fool2
vert_correction_fc1_2022 <- data.frame(ID = c(0:1), offset=c(0.0000))%>%
  mutate(cumOffset = cumsum(offset))
```


```{r badid2fc2_22, include=FALSE}   
bad_id <- bad_id_fc2_2022
vert_correction <- vert_correction_fc1_2022
```

##### 4) Vertical adjustments
```{r vertcorrectfc2_22}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw,maxgap=8)%>%
    filter(ID > 2021) %>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

#stageAdj$site<- site
#stageAdj$watershed<-watershed
```

#### Plot adjusted stage
```{r plot4fc2_22, fig.align = "center", fig.cap = "Figure 3.2.4: Stage data from Fool 2 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}

dyStageAdj(df=stage_adj)

```

#### Plot adjusted values only:
```{r plot5fc2_22, fig.align = "center", fig.cap = "Figure 3.2.5: Same as 3.2.4 but limited to adjusted values only.", echo=FALSE}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc2_22 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```


#### Check manual measurements
```{r importmanualfc2_22}
# load manual measurements
# interfiles <- 'formatted_data/manual_measurements'
# file_path <- paste(getwd(),interfiles,paste(site,'.csv', sep = ""), sep='/')
# 
# manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)
# 
# manMeas<- read.csv(file_path)%>%
#       #timezone set to MST, change if loggers used MDT/MST
#       mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
#       mutate(water_depth = dep_to_bed-dep_to_water)%>%
#       mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc2_22}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
# stat_to_bed <- manMeas%>%
#   summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
#   pull(mean_dep_to_bed)
# 
# manMeas_fil <- manMeas %>%
#       #filter(watershed == watershed)%>%
#       #filter(site == site)%>%
#       dplyr::rename(., wtr_depth_not_static = water_depth) %>%
#       mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
# ### 10 to convert mm to cm
# 
# depth_offset <- manMeas_fil %>%
#   slice_min(datetime)%>%
#   left_join(stage_adj %>%
#               dplyr::select(datetime, adj_wtr_ht))%>%
#   mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
#   pull(depth_offset)
```


#### Manual adjustments: 
```{r plot6fc2_22,, fig.align = "center", fig.cap = "Figure 3.2.6: Adjusted stage data from Fool 2 which includes a manual offset that adjusts all values in the dataframe. "}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
# manual_offset <- 0
# # fc1 = 
# # fc2 = 0
# stage_adj <- stage_adj%>%
#   mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)
# 
# stage_adj <- stage_adj%>%
#   mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

#### Compare cleaned water level to manual measurements
```{r plot7fc2_22, fig.align = "center"}
#plot difference between measured water depth and manual depth measurement
# stage_adj <- as.data.frame(stage_adj)
# stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
#       mutate(diff = man_wtr_dep_static-wtr_depth)
# 
# ggplot(stageAdj.man, aes(datetime, diff))+
#   geom_point(size=3)+
#   theme_minimal()
```


```{r plot8fc2_22, fig.align = "center", fig.cap = "Figure 3.2.7: Adjusted stage data with manual measurements (points)"}
#plot water level time series with manual measurements as points
# stage_check_plot<- stage_adj%>%
#   dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
#   #ggplot(aes(datetime,adj_wtr_ht))+
#   ggplot(aes(datetime,wtr_depth))+
#     geom_line()+
#     geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')
# 
# ggplotly(stage_check_plot)
```

#### Export cleaned data
```{r savefc2_22}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
  #dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))

```



## 2022 - Fool3


```{r importfc3_22, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2022
watershed<- 'fool'
site <- 'fc3'

stage_raw <- concat_2022(opn_as_dflist(interfiles, year, watershed, site)) 

```

Quick raw plot of point data
```{r plot1fc3_22, fig.align = "center", fig.cap = 'Figure 3.3.1: Raw data for Fool 3 stage in 2022.', echo=FALSE}
#quick plot of stage
ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line()

```

#### Create complete timeseries to identify any missing datetimes from the dataframe
```{r checktimefc3_22, echo=FALSE, results = 'asis'}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```

```{r checktime2fc3_22, echo=FALSE, results = 'asis'}

cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```

#### Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc3_22, fig.align = "center", fig.cap = "Figure 3.3.2: Air temperature data captured by the capacitance rod Fool 3 in 2022.", echo=FALSE}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

```

2) Plot raw data with flag if raw level changes by more than 2%.

```{r plantflagsfc3_22, fig.align = "center", fig.cap = "Figure 3.3.3: Raw stage data from Fool 3 2022 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc3_22}
#fool3
bad_id_fc3_2022 <- c(10782:10788)

#fool3
vert_correction_fc3_2022 <- data.frame(ID = c(8175:8176), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))
```


```{r badid2fc3_22, include=FALSE}    
bad_id <- bad_id_fc3_2022

vert_correction <- vert_correction_fc3_2022

```

4) Vertical adjustments
```{r vertcorrectfc3_22}
#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df = stage_raw,maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot4fc3_22, fig.align = "center", fig.cap = "Figure 3.3.4: Stage data from Fool 3 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}

dyStageAdj(df=stage_adj)

```

Plot adjusted values only:
```{r plot5fc3_22, fig.align = "center", fig.cap = "Figure 3.3.5: Same as 3.3.4 but limited to adjusted values only.", echo=FALSE}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc3_22 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```


#### Check manual measurements
```{r importmanualfc3_22}
# load manual measurements
# interfiles <- 'formatted_data/manual_measurements'
# file_path <- paste(getwd(),interfiles,paste(site,'.csv', sep = ""), sep='/')
# 
# manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)
# 
# manMeas<- read.csv(file_path)%>%
#       #timezone set to MST, change if loggers used MDT/MST
#       mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
#       mutate(water_depth = dep_to_bed-dep_to_water)%>%
#       mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc3_22}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
# stat_to_bed <- manMeas%>%
#   summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
#   pull(mean_dep_to_bed)
# 
# manMeas_fil <- manMeas %>%
#       #filter(watershed == watershed)%>%
#       #filter(site == site)%>%
#       dplyr::rename(., wtr_depth_not_static = water_depth) %>%
#       mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
# ### 10 to convert mm to cm
# 
# depth_offset <- manMeas_fil %>%
#   slice_min(datetime)%>%
#   left_join(stage_adj %>%
#               dplyr::select(datetime, adj_wtr_ht))%>%
#   mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
#   pull(depth_offset)
```


Manual adjustments: 
```{r plot6fc3_22,, fig.align = "center", fig.cap = "Figure 3.3.6: Adjusted stage data from Fool 3 which includes a manual offset that adjusts all values in the dataframe. "}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
# manual_offset <- 5
# # fc1 = 
# # fc2 = 0
# stage_adj <- stage_adj%>%
#   mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)
# 
# stage_adj <- stage_adj%>%
#   mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

#### Compare cleaned water level to manual measurements
```{r plot7fc3_22, fig.align = "center"}
#plot difference between measured water depth and manual depth measurement
# stage_adj <- as.data.frame(stage_adj)
# stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
#       mutate(diff = man_wtr_dep_static-wtr_depth)
# 
# ggplot(stageAdj.man, aes(datetime, diff))+
#   geom_point(size=3)+
#   theme_minimal()
```


```{r plot8fc3_22, fig.align = "center", fig.cap = "Figure 3.3.7: Adjusted stage data with manual measurements (points)"}
#plot water level time series with manual measurements as points
# stage_check_plot<- stage_adj%>%
#   dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
#   ggplot(aes(datetime,wtr_depth))+
#     geom_line()+
#     geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')
# 
# ggplotly(stage_check_plot)
```

#### Export cleaned data
```{r savefc3_22}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
  #dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```


## 2022 - Fool4


```{r importfc4_22, include=FALSE}

interfiles <- 'formatted_data/stage_caprod'
year <- 2022
watershed<- 'fool'
site <- 'fc4'

stage_raw <- concat_2022(opn_as_dflist(interfiles, year, watershed, site)) 

```

Quick raw plot of point data
```{r plot1fc4_22, fig.align = "center", fig.cap = 'Figure 3.4.1: Raw data for Fool 4 stage in 2022.', echo=FALSE}

#quick plot of stage
ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line()

```

#### Create complete timeseries to identify any missing datetimes from the dataframe
```{r checktimefc4_22, echo=FALSE, results = 'asis'}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
cat(paste('Datetime intervals greater than 1 include:', sep = ''), checkTimeSteps(), sep = "\n")


ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw, by='datetime')

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
```


```{r checktime2fc4_22}
cat(paste0(
  "- `", 'The number of missing timesteps is ', length(miss_ts), "`", sep = "\n"))

```

#### Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc4_22, fig.align = "center", fig.cap = "Figure 3.4.2: Air temperature data captured by the capacitance rod Fool 4 in 2022.", echo=FALSE}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

```

2) Plot raw data with flag if raw level changes by more than 2%.

```{r plantflagsfc4_22, fig.align = "center", fig.cap = "Figure 3.4.3: Raw stage data from Fool 4 2022 with 'flags' where average stage changes by more than 20% in a single timestep", echo=FALSE}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot

```{r badidfc4_22}
#9862:9865 - get rid of
#9446:9861 (364-599  = 235) 602
stage_raw[9536:9861,]$wtr_ht_avg <- stage_raw[9536:9861,]$wtr_ht_avg - 203
#fool3
bad_id_fc4_2022 <- c(9535:9553, 9862:9865)

#fool3
vert_correction_fc4_2022<- data.frame(ID = c(8175:8176), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))
```


```{r badid2fc4_22, include=FALSE}    
bad_id <- bad_id_fc4_2022

vert_correction <- vert_correction_fc4_2022

```

4) Vertical adjustments
```{r vertcorrectfc4_22}
#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw,maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot4fc4_22, fig.align = "center", fig.cap = "Figure 3.4.4: Stage data from Fool 4 after the first round of adjustments, which include eliminating points where rod was out of the stream for periodic downloading and eliminating points collected after rod was removed from the stream. Both raw and adjusted values are shown", echo=FALSE}

dyStageAdj(df=stage_adj)

```

look at the adjusted values only
```{r plot3fc4, fig.align = "center", fig.cap = "Figure 3.4.5: Same as 3.4.4 but limited to adjusted values only.", echo=FALSE}
dyStageAdjonly<- function(df = stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj, main = site) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 800))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

simplefc4_22 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```

#### Check manual measurements
```{r importmanualfc4_22}
# load manual measurements
# interfiles <- 'formatted_data/manual_measurements'
# file_path <- paste(getwd(),interfiles,paste(site,'.csv', sep = ""), sep='/')
# 
# manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)
# 
# manMeas<- read.csv(file_path)%>%
#       #timezone set to MST, change if loggers used MDT/MST
#       mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'10 minutes'))%>% 
#       mutate(water_depth = dep_to_bed-dep_to_water)%>%
#       mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc4_22}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
# stat_to_bed <- manMeas%>%
#   summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
#   pull(mean_dep_to_bed)
# 
# manMeas_fil <- manMeas %>%
#       #filter(watershed == watershed)%>%
#       #filter(site == site)%>%
#       dplyr::rename(., wtr_depth_not_static = water_depth) %>%
#       mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
# ### 10 to convert mm to cm
# 
# depth_offset <- manMeas_fil %>%
#   slice_min(datetime)%>%
#   left_join(stage_adj %>%
#               dplyr::select(datetime, adj_wtr_ht))%>%
#   mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
#   pull(depth_offset)
# 
# depth_offset
```


Manual adjustments: 
```{r plot6fc4_22,, fig.align = "center", fig.cap = "Figure 3.4.6: Adjusted stage data from Fool 4 which includes a manual offset that adjusts all values in the dataframe. "}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
# manual_offset <- 0
# # fc1 = 
# # fc2 = 0
# stage_adj <- stage_adj%>%
#   mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)
# 
# stage_adj <- stage_adj%>%
#   mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

#### Compare cleaned water level to manual measurements
```{r plot7fc7_22, fig.align = "center"}
#plot difference between measured water depth and manual depth measurement
# stage_adj <- as.data.frame(stage_adj)
# stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
#       mutate(diff = man_wtr_dep_static-wtr_depth)
# 
# ggplot(stageAdj.man, aes(datetime, diff))+
#   geom_point(size=3)+
#   theme_minimal()
```


```{r plot8fc4_22, fig.align = "center", fig.cap = "Figure 3.4.7: Adjusted stage data with manual measurements (points)"}
#plot water level time series with manual measurements as points
# stage_check_plot<- stage_adj%>%
#   dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
#   ggplot(aes(datetime,wtr_depth))+
#     geom_line()+
#     geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')
# 
# ggplotly(stage_check_plot)
```

#### Export cleaned data
```{r savefc4_22}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
  #dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```

## 2022 Site stack
Stack sites in a plot to 
1. check interannual variation
2. verify/modify vertical corrections

```{r}
allfc <- rbind(simplefc1_22,simplefc2_22) 
allfc <- rbind(allfc,simplefc3_22) 
allfc <- rbind(allfc,simplefc4_22)

sitestack_22 <- ggplot(allfc, aes(x = datetime, y = adj_wtr_ht, color = site)) +
  geom_line()

sitestack_22
```

```{r}
ggarrange(sitestack_20, sitestack_21, sitestack_22, 
          labels = c("A", "B", "C"),
          ncol = 2, nrow = 2)
```

## Plot years separate lines
```{r}
fc_1 <- rbind(simplefc1_20,simplefc1_21) 
fc_1 <- rbind(fc_1,simplefc1_22) 
fc_1 <-fc_1 %>%
mutate(year = as.factor(year(datetime)), # A hack. Set year to 2018. Allows me to use a date axis
    date_foo = as.Date(paste(2020, format(datetime, "%m-%d"), sep = "-"))) 


fc1_plot <- fc_1 %>%
  ggplot(aes(x=date_foo, y=adj_wtr_ht, col=year, group=year)) +
  geom_line() +
  ggtitle(paste("seasonal plot", site)) +
  theme_minimal(base_size = 8) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b-%d")

fc1_plot
```

```{r}
fc_2 <- rbind(simplefc2_20,simplefc2_21) 
fc_2 <- rbind(fc_2,simplefc2_22) 
fc_2 <-fc_2 %>%
mutate(year = as.factor(year(datetime)), # A hack. Set year to 2018. Allows me to use a date axis
    date_foo = as.Date(paste(2020, format(datetime, "%m-%d"), sep = "-"))) 


fc2_plot <- fc_2 %>%
  ggplot(aes(x=date_foo, y=adj_wtr_ht, col=year, group=year)) +
  geom_line() +
  ggtitle(paste("seasonal plot", site)) +
  theme_minimal(base_size = 8) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b-%d")

fc2_plot
```

```{r}
fc_3 <- rbind(simplefc3_20,simplefc3_21) 
fc_3 <- rbind(fc_3,simplefc3_22) 
fc_3 <-fc_3 %>%
mutate(year = as.factor(year(datetime)), # A hack. Set year to 2018. Allows me to use a date axis
    date_foo = as.Date(paste(2020, format(datetime, "%m-%d"), sep = "-"))) 


fc3_plot <- fc_3 %>%
  ggplot(aes(x=date_foo, y=adj_wtr_ht, col=year, group=year)) +
  geom_line() +
  ggtitle(paste("seasonal plot", site)) +
  theme_minimal(base_size = 8) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b-%d")

fc3_plot
```

```{r}
fc_4 <- rbind(simplefc4_20,simplefc4_21) 
fc_4 <- rbind(fc_4,simplefc4_22) 
fc_4 <-fc_4 %>%
mutate(year = as.factor(year(datetime)), # A hack. Set year to 2018. Allows me to use a date axis
    date_foo = as.Date(paste(2020, format(datetime, "%m-%d"), sep = "-"))) 


fc4_plot <- fc_4 %>%
  ggplot(aes(x=date_foo, y=adj_wtr_ht, col=year, group=year)) +
  geom_line() +
  ggtitle(paste("seasonal plot", site)) +
  theme_minimal(base_size = 8) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b-%d")

fc4_plot
```

```{r}

```

