---
title: "Cap Rod Cleaning - Fool Creek "
author: "Adapted for FEF by LKremer"
date: `r Sys.Date()`
output: html_document
editor_options: 
  chunk_output_type: console
---

Script for cleaning water level data from TruTrak capacitance rods. 
Designed for surface water level measurements.
Cleaning and QA/QC steps include 

1) removing bad data
2) adjusting data for shifts in logger position
3) converting stage to water depth
4) checking results against manual measurements.

Requires capacitance rod raw data and manual measurement spreadsheet

##Setup

```{r, include=FALSE}

pkgTest <- function(x)
{
  if (x %in% rownames(installed.packages()) == FALSE) {
    install.packages(x, dependencies= TRUE)
  }
  library(x, character.only = TRUE)
}

# Make a vector of the packages you need
neededPackages <- c('tidyverse', 'lubridate', 'xts', 'dygraphs', 'ggrepel','knitr', 'plotly') #tools for plot titles 

# For every package in the vector, apply your pkgTest function
for (package in neededPackages){pkgTest(package)}

source('./functions/stageFunctions.R') #load helper functions
```

##Additional functions

```{r functions, include=FALSE}

# A universal function to open all caprod data for a 'site' to a list of dataframes
opn_as_dflist <- function(interfiles, year, watershed, site) {
   file_path <- paste(getwd(), interfiles, year, watershed, site, sep='/')
   path_list <- paste(file_path, list.files(file_path), sep= '/')
   data <- lapply(path_list, function(x) {
      dat <- read.table(x, skip = 0, header = TRUE, sep = ",", row.names = NULL, as.is = TRUE)
      # for each item in path list, grab the cap_rod number
      dat$rod_no <- unlist(strsplit(unlist(strsplit(path_list[1], "_"))[8], "[.]"))[1]
      return(dat)
   })
}

# Each year of data has been formatted a bit differently. Rather than reformatting each spreadsheet, 
# a function specific to each year should concatenate the list made by 'opn_as_dflist' 
concat_2020 <- function(data) {
   drops <- c('sample')
   combined.data <- do.call(rbind, data)
   combined.data <- combined.data %>%
     mutate(datetime = lubridate::mdy_hms(datetime)) %>%
     arrange(datetime) %>%
     distinct() %>%
     dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%               rowid_to_column(var='ID') %>%
     select(-one_of(drops))%>%
   return(combined.data)
}
```

#2020

##2020 - Fool1 

Caprod data collection terminated on November 4, 2020 for all Fool sites except for Fool1, which was noted to be pulled by Kelly on October 20, 2020 (ID~16000)

```{r importfc1, include=FALSE}

interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc1'

stage_raw <- concat_2020(opn_as_dflist(interfiles, year, watershed, site))

```

####Quick raw plot of point data
```{r rawpltfc1}

#quick plot of stage
ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "water height point")

```

####Create complete timeseries to identify any missing datetimes from the dataframe
```{r checktimefc1}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc1}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

# Temperature is variable (dry?) ~ID#16685
```

2) Plot raw data with flag if raw level changes by more than 2%.
```{r plantflagsfc1}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc1}

#fool1
bad_id_fc1_2020 <- c(977:981, 5050:5053, 10953:10957)

#fool1
vert_correction_fc1_2020 <- data.frame(ID = c(8175:8176), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))

# correcting functions accept 'bad_id' and 'vert_correction' vectors  
bad_id <- bad_id_fc1_2020
vert_correction <- vert_correction_fc1_2020
```

4) Vertical adjustments
```{r correctfc1}
# November 4 ~ID no. 18142, but may have been pulled or dry sooner
#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df=stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    filter(ID < 16000) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot2fc1}

#plot adjusted stage
dyStageAdj(df=stage_adj)

```

Plot adjusted values only:
```{r plot3fc1}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc1_20 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```

If no manual measurements accompany dataset (as is the case in 2020), then data can be exported.
Figures of:
1. all stage data for a watershed in a given year 
2. stage data for all years for each site
can help to verify trends and inform adjustments (see below)

###Export cleaned data
```{r exportfc1}

stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) #adj_wtr_ht will need to be changed to water_depth once manual measurements are considered.
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')

#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```



##2020 - Fool2 



```{r importfc2, include=FALSE}

interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc2'

stage_raw <- concat_2020(opn_as_dflist(interfiles, year, watershed, site))

```

```{r plot1fc2}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "water height point")

```

####Create complete timeseries to identify any missing datetimes from the dataframe
```{r checktimefc2}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc2}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'
```

2) Plot raw data with flag if raw level changes by more than 2%.
```{r plantflagsfc2}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc2}
#fool2
bad_id_fc2_2020 <- c(4953:4960, 11952:12730)

vert_correction_fc2_2020 <- data.frame(ID = c(1:2), offset=c(0.00)) %>%
  mutate(cumOffset = cumsum(offset))

bad_id <- bad_id_fc2_2020
vert_correction <- vert_correction_fc2_2020
```

4) Vertical adjustments
```{r correctfc2}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df=stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    #filter(ID < 12730) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot2fc2}

#plot adjusted stage
dyStageAdj(df=stage_adj)

```

Plot adjusted values only:
```{r plot3fc2}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc2_20 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```

If no manual measurements accompany dataset (as is the case in 2020), then data can be exported.
Figures of:
1. all stage data for a watershed in a given year 
2. stage data for all years for each site
can help to verify trends and inform adjustments (see below)

###Export cleaned data
```{r exportfc2}

stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) #adj_wtr_ht will need to be changed to water_depth once manual measurements are considered.
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')

#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```


## 2020 - Fool3 


```{r importfc3, include=FALSE}

interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc3'

stage_raw <- concat_2020(opn_as_dflist(interfiles, year, watershed, site))

```

```{r plot1fc3}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "water height point")

```

####Create complete timeseries to identify any missing datetimes from the dataframe
```{r checktimefc3}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc3}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'
```

2) Plot raw data with flag if raw level changes by more than 2%.
```{r plantflagsfc3}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc3}
#fool3
bad_id_fc3_2020 <- c(5182:5186)

vert_correction_f3_2020 <- data.frame(ID = c(7860:12965), offset=c(20)) %>%
  mutate(cumOffset = offset)

bad_id <- bad_id_fc3_2020
vert_correction<- vert_correction_f3_2020
```

4) Vertical adjustments
```{r correctfc3}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df=stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    filter(ID < 12210) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot2fc3}

#plot adjusted stage
dyStageAdj(df=stage_adj)

```

Plot adjusted values only:
```{r plot3fc3}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc3_20 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```

If no manual measurements accompany dataset (as is the case in 2020), then data can be exported.
Figures of:
1. all stage data for a watershed in a given year 
2. stage data for all years for each site
can help to verify trends and inform adjustments (see below)

###Export cleaned data
```{r exportfc3}

stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) #adj_wtr_ht will need to be changed to water_depth once manual measurements are considered.
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')

#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```


##2020 - Fool4  


```{r importfc4, include=FALSE}

interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc4'

stage_raw <- concat_2020(opn_as_dflist(interfiles, year, watershed, site))

```

```{r plot1fc4}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "water height point")
  
```

####Create complete timeseries to identify any missing datetimes from the dataframe
```{r checktimefc4}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc4}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'
```

2) Plot raw data with flag if raw level changes by more than 2%.
```{r plantflagsfc4}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc4}
#fool4
bad_id_fc4_2020 <- c(5182:5186, 5909:5912)

vert_correction_f4_2020 <- data.frame(ID = c(7860:12965), offset=c(0.00)) %>%
  mutate(cumOffset = cumsum(offset))

bad_id <- bad_id_fc4_2020
vert_correction<- vert_correction_f4_2020
```

4) Vertical adjustments
```{r correctfc4}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df=stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    filter(ID < 12966) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot2fc4}

#plot adjusted stage
dyStageAdj(df=stage_adj)

```

Plot adjusted values only:
```{r plot3fc4}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple plot of adjusted values for stacking (see below)
simplefc4_20 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```

If no manual measurements accompany dataset (as is the case in 2020), then data can be exported.
Figures of:
1. all stage data for a watershed in a given year 
2. stage data for all years for each site
can help to verify trends and inform adjustments (see below)

###Export cleaned data
```{r exportfc4}

stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, adj_wtr_ht, level_flag) #adj_wtr_ht will need to be changed to water_depth once manual measurements are considered.
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')

#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```

##2020 Site stack
Stack sites in a plot to 
1. check interannual variation
2. verify/modify vertical corrections

```{r}
allfc <- rbind(simplefc1_20,simplefc2_20) 
allfc <- rbind(allfc,simplefc3_20) 
allfc <- rbind(allfc,simplefc4_20)

ggplot(allfc, aes(x = datetime, y = adj_wtr_ht, color = site)) +  
  geom_line()
```






#2021

All Fool data terminated 9/29/21 
```{r functions, include=FALSE}
concat_2021 <- function(data) {
   drops <- c("formatted_datetime", 'sample')
   combined.data <- do.call(rbind, data)
   combined.data <- combined.data %>%
     mutate(datetime = lubridate::mdy_hm(datetime)) %>%
     arrange(datetime) %>%
     dplyr::distinct() %>%
     dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%      rowid_to_column(var='ID') %>%
     select(-one_of(drops))
   return(combined.data)
}
```

##2021 - Fool1

```{r importfc1_21, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2021
watershed<- 'fool'
site <- 'fc1'

stage_raw <- concat_2021(opn_as_dflist(interfiles, year, watershed, site)) %>%
  drop_na()

```

```{r plot1fc1_21}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "water height point")

```

####Create complete timeseries to identify any missing datetimes from the dataframe
```{r checktimefc1_21}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
#checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = lubridate::round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc1_21}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

# Looks like air temp until ~ID273
```

2) Plot raw data with flag if raw level changes by more than 2%.
```{r plantflagsfc1_21}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc1_21}
#fool2
bad_id_fc1_2021 <-  c(0:289, 1895:1898, 2910:2914, 4053:4056, 4944:4948, 8099:8103, 14991:14994, 18129:18132)

#fool2
vert_correction_fc1_2021<- data.frame(ID = c(8175:8186), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))
  
bad_id <- bad_id_fc1_2021
vert_correction <- vert_correction_fc1_2021
```

4) Vertical adjustments
```{r correctfc1_21}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df=stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    filter(ID < 12210) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

```

#### Plot adjusted stage
```{r plot2fc3}

#plot adjusted stage
dyStageAdj(df=stage_adj)

```

Plot adjusted values only:
```{r plot3fc3}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc1_21 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```


####Check manual measurements
```{r importmanualfc1_21}
# load manual measurements
interfiles <- 'formatted_data/discharge/formatted_manual_measurements'
file_path <- paste(getwd(),interfiles,paste(site,'.csv', sep = ""), sep='/')

manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)

manMeas<- read.csv(file_path)%>%
      #timezone set to MST, change if loggers used MDT/MST
      mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
      mutate(water_depth = dep_to_bed-dep_to_water)%>%
      mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc1_21}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
stat_to_bed <- manMeas%>%
  summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
  pull(mean_dep_to_bed)

manMeas_fil <- manMeas %>%
      #filter(watershed == watershed)%>%
      #filter(site == site)%>%
      dplyr::rename(., wtr_depth_not_static = water_depth) %>%
      mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
### 10 to convert mm to cm

depth_offset <- manMeas_fil %>%
  slice_min(datetime)%>%
  left_join(stage_adj %>%
              dplyr::select(datetime, adj_wtr_ht))%>%
  mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
  pull(depth_offset)
```


```{r wtrdepthfc1_21}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
manual_offset <- 5
# fc1 = 
# fc2 = 0
stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)

stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

####Compare cleaned water level to manual measurements
```{r plot4fc1_21}
#plot difference between measured water depth and manual depth measurement
stage_adj <- as.data.frame(stage_adj)
stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
      mutate(diff = man_wtr_dep_static-wtr_depth)

ggplot(stageAdj.man, aes(datetime, diff))+
  geom_point(size=3)+
  theme_minimal()
```


```{r plot5fc1_21}
#plot water level time series with manual measurements as points
stage_check_plot<- stage_adj%>%
  dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
  ggplot(aes(datetime,wtr_depth))+
    geom_line()+
    geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')

ggplotly(stage_check_plot)
```

###Export cleaned data
```{r savefc1_21}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))

```

##2021 - Fool2


```{r importfc2_21, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2021
watershed<- 'fool'
site <- 'fc2'

stage_raw <- concat_2021(opn_as_dflist(interfiles, year, watershed, site)) 

```


```{r plot1fc2_21}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line()

```

####Create complete timeseries to identify any missing datetimes from the dataframe
```{r checktimefc2_21}
#check if collection interval is consistent in dataset. Function as written only handles one interval but can be modified if interval was changed. 
#checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = lubridate::round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature for quick checks
 
```{r chktempfc2_21}

#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

# Looks like air temp until ~ID273
```

2) Plot raw data with flag if raw level changes by more than 2%.
```{r plantflagsfc2_21}

#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc2_21}
#fool2
bad_id_fc2_2021 <- c(0:219,1174:1178, 4288:4293, 11104:11107, 16256:16257)

#fool2
vert_correction_fc1_2021 <- data.frame(ID = c(4262:16257), offset=c(-.0015))%>%
  mutate(cumOffset = cumsum(offset))
  
bad_id <- bad_id_fc2_2021
vert_correction <- vert_correction_fc1_2021
```

4) Vertical adjustments
```{r vertcorrectfc2_21}

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw,maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

#stageAdj$site<- site
#stageAdj$watershed<-watershed
```

#### Plot adjusted stage
```{r plot2fc3}

#plot adjusted stage
dyStageAdj(df=stage_adj)

```

Plot adjusted values only:
```{r plot3fc3}

dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

# Simple df of adjusted values for stacked plot (see below)
simplefc1_21 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```


####Check manual measurements
```{r importmanualfc1_21}
# load manual measurements
interfiles <- 'formatted_data/discharge/formatted_manual_measurements'
file_path <- paste(getwd(),interfiles,paste(site,'.csv', sep = ""), sep='/')

manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)

manMeas<- read.csv(file_path)%>%
      #timezone set to MST, change if loggers used MDT/MST
      mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
      mutate(water_depth = dep_to_bed-dep_to_water)%>%
      mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc1_21}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
stat_to_bed <- manMeas%>%
  summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
  pull(mean_dep_to_bed)

manMeas_fil <- manMeas %>%
      #filter(watershed == watershed)%>%
      #filter(site == site)%>%
      dplyr::rename(., wtr_depth_not_static = water_depth) %>%
      mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
### 10 to convert mm to cm

depth_offset <- manMeas_fil %>%
  slice_min(datetime)%>%
  left_join(stage_adj %>%
              dplyr::select(datetime, adj_wtr_ht))%>%
  mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
  pull(depth_offset)
```


```{r wtrdepthfc1_21}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
manual_offset <- 0
# fc1 = 
# fc2 = 0
stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)

stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

####Compare cleaned water level to manual measurements
```{r plot4fc1_21}
#plot difference between measured water depth and manual depth measurement
stage_adj <- as.data.frame(stage_adj)
stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
      mutate(diff = man_wtr_dep_static-wtr_depth)

ggplot(stageAdj.man, aes(datetime, diff))+
  geom_point(size=3)+
  theme_minimal()
```


```{r plot5fc1_21}
#plot water level time series with manual measurements as points
stage_check_plot<- stage_adj%>%
  dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
  ggplot(aes(datetime,wtr_depth))+
    geom_line()+
    geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')

ggplotly(stage_check_plot)
```

###Export cleaned data
```{r savefc1_21}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))

```







```{r importfc3_21, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2021
watershed<- 'fool'
site <- 'fc3'

stage_raw <- opn_concat(interfiles, year, watershed, site)

stage_raw <- stage_raw %>%
  dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%
  rowid_to_column(var='ID')

```


```{r plot1fc3_21}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line()

```

###Create complete timeseries that includes any missing datetimes
```{r checktimefc3_21}
#check if collection interval is consistent in dataset. Code as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)


#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature, battery for quick checks
2) Add ID column to use for identifying bad data
3) Plot raw data with flag if raw level changes by more than x%. 

```{r plantflagsfc3_21}
#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

#check battery (FEF caprods may not have battery log)
#DyBatt()

#add new ID column to ensure unique ID for each datetime
stage_raw_prep <- stage_raw%>%
  dplyr::select(-ID)%>% #remove ID column from raw data
  arrange(datetime)%>%
  rowid_to_column(var='ID')

#Raw stage plot
DyRawStage(df=stage_raw_prep,threshold = 0.2, flag='TRUE')
```


```{r badidfc3_21}
#fool3
bad_id_fc3_2021 <- c(1166:1170, 4283:4287, 10091:10095)

#fool3
vert_correction_fc3_2021<- data.frame(ID = c(8175:8176), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))
  
bad_id <- bad_id_fc3_2021

vert_correction <- vert_correction_fc3_2021

```


```{r vertcorrectfc3_21}
#turn bad data points into NAs
vert_correction<- data.frame(ID = c(5075:5076), offset=c(-0.002))%>%
  mutate(cumOffset = cumsum(offset))

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw_prep,maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

#stageAdj$site<- site
#stageAdj$watershed<-watershed
```


```{r plot2fc3_21}
#plot adjusted stage
dyStageAdj(df=stage_adj)

```

# look at the adjusted values only
```{r plot3fc3_21}
dyStageAdjonly<- function(df = stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)
```

## Check manual measurements
```{r importmanualfc3_21}
# load manual measurements
interfiles <- 'formatted_data/discharge/formatted_manual_measurements'
file_path <- paste(getwd(),interfiles,paste(site,'.csv', sep = ""), sep='/')

manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)

manMeas<- read.csv(file_path)%>%
      #timezone set to MST, change if loggers used MDT/MST
      mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
      mutate(water_depth = dep_to_bed-dep_to_water)%>%
      mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc3_21}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
stat_to_bed <- manMeas%>%
  summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
  pull(mean_dep_to_bed)

manMeas_fil <- manMeas %>%
      #filter(watershed == watershed)%>%
      #filter(site == site)%>%
      dplyr::rename(., wtr_depth_not_static = water_depth) %>%
      mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
### 10 to convert mm to cm

depth_offset <- manMeas_fil %>%
  slice_min(datetime)%>%
  left_join(stage_adj %>%
              dplyr::select(datetime, adj_wtr_ht))%>%
  mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
  pull(depth_offset)
```


```{r wtrdepthfc3_21}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
manual_offset <- 5
# fc1 = 
# fc2 = 0
stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)

stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

###compare cleaned water level to manual measurements
```{r plot4fc3_21}
#plot difference between measured water depth and manual depth measurement
stage_adj <- as.data.frame(stage_adj)
stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
      mutate(diff = man_wtr_dep_static-wtr_depth)

ggplot(stageAdj.man, aes(datetime, diff))+
  geom_point(size=3)+
  theme_minimal()
```


```{r plot5fc3_21}
#plot water level time series with manual measurements as points
stage_check_plot<- stage_adj%>%
  dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
  ggplot(aes(datetime,wtr_depth))+
    geom_line()+
    geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')

ggplotly(stage_check_plot)
```

###save
```{r savefc32021}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```








```{r importfc4_21, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2021
watershed<- 'fool'
site <- 'fc4'

stage_raw <- opn_concat(interfiles, year, watershed, site)

stage_raw <- stage_raw %>%
  dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%
  rowid_to_column(var='ID')

```


```{r plot1fc4_21}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line()

```

###Create complete timeseries that includes any missing datetimes
```{r checktimefc4_21}
#check if collection interval is consistent in dataset. Code as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)


#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature, battery for quick checks
2) Add ID column to use for identifying bad data
3) Plot raw data with flag if raw level changes by more than x%. 

```{r plantflagsfc4_21}
#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

#check battery (FEF caprods may not have battery log)
#DyBatt()

#add new ID column to ensure unique ID for each datetime
stage_raw_prep <- stage_raw%>%
  dplyr::select(-ID)%>% #remove ID column from raw data
  arrange(datetime)%>%
  rowid_to_column(var='ID')

#Raw stage plot
DyRawStage(df=stage_raw_prep,threshold = 0.2, flag='TRUE')
```


```{r badidfc4_21}
#fool3
bad_id_fc4_2021 <- c(3900:3905, 8965:8969, 10967:10971)

#fool3
vert_correction_fc4_2021<- data.frame(ID = c(8175:8176), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))
  
bad_id <- bad_id_fc4_2021

vert_correction <- vert_correction_fc4_2021

```


```{r vertcorrectfc4_21}
#turn bad data points into NAs
vert_correction<- data.frame(ID = c(5075:5076), offset=c(-0.000))%>%
  mutate(cumOffset = cumsum(offset))

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw_prep,maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

#stageAdj$site<- site
#stageAdj$watershed<-watershed
```


```{r plot2fc4_21}
#plot adjusted stage
dyStageAdj(df=stage_adj)

```

# look at the adjusted values only
```{r plot3fc4_21}
dyStageAdjonly<- function(df = stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)
```

## Check manual measurements
```{r importmanualfc4_21}
# load manual measurements
interfiles <- 'formatted_data/discharge/formatted_manual_measurements'
file_path <- paste(getwd(),interfiles,paste(site,'.csv', sep = ""), sep='/')

manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)

manMeas<- read.csv(file_path)%>%
      #timezone set to MST, change if loggers used MDT/MST
      mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'10 minutes'))%>% 
      mutate(water_depth = dep_to_bed-dep_to_water)%>%
      mutate(staff = as.numeric(staff))
```


```{r depthoffsetfc4_21}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
stat_to_bed <- manMeas%>%
  summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
  pull(mean_dep_to_bed)

manMeas_fil <- manMeas %>%
      #filter(watershed == watershed)%>%
      #filter(site == site)%>%
      dplyr::rename(., wtr_depth_not_static = water_depth) %>%
      mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
### 10 to convert mm to cm

depth_offset <- manMeas_fil %>%
  slice_min(datetime)%>%
  left_join(stage_adj %>%
              dplyr::select(datetime, adj_wtr_ht))%>%
  mutate(depth_offset = man_wtr_dep_static-adj_wtr_ht)%>%
  pull(depth_offset)

depth_offset
```


```{r wtrdepthfc4_21}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
manual_offset <- 0
# fc1 = 
# fc2 = 0
stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)

stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

###compare cleaned water level to manual measurements
```{r plot4fc4_21}
#plot difference between measured water depth and manual depth measurement
stage_adj <- as.data.frame(stage_adj)
stageAdj.man<- dplyr::left_join(manMeas_fil,stage_adj, by = 'datetime') %>%
      mutate(diff = man_wtr_dep_static-wtr_depth)

ggplot(stageAdj.man, aes(datetime, diff))+
  geom_point(size=3)+
  theme_minimal()
```


```{r plot5fc4_21}
#plot water level time series with manual measurements as points
stage_check_plot<- stage_adj%>%
  dplyr::left_join(.,manMeas_fil, by = 'datetime') %>%
  ggplot(aes(datetime,wtr_depth))+
    geom_line()+
    geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')

ggplotly(stage_check_plot)
```

###save
```{r savefc42021}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```



#fool2
bad_id <- c(0:219,1174:1178, 4288:4293, 11104:11107, 16256:16257)

#fool2 (Jul8 16:00 - 1454: Sept1 1:00 - 12916 -> 10/)
vert_correction<- data.frame(ID = c(1454:12916), offset=c(-0.0015))%>%
  mutate(cumOffset = cumsum(offset))
#-0.0008724

#fool3
bad_id <- c(0:5, 1166:1169, 4283:4286, 10091:10094)

#fool3 (Jul17 12:00 - 5624: Sept16 12:00 - 14408 -> 19)
vert_correction<- data.frame(ID = c(5624:14408),offset=c(-0.0025))%>%
  mutate(cumOffset = cumsum(offset))
  
#fool4
bad_id <- c(0:4, 3900:3905, 8965:8969, 10967:10970, 15117:15121)

#29 June 18:00 1771
vert_correction<- data.frame(ID = c(5083:15116), offset=c(0.0005))%>%
  mutate(cumOffset = cumsum(offset))






## 2022 clean 
```{r}
opn_concat <- function(interfiles, year, watershed, site) {
   file_path <- paste(getwd(), interfiles, year, watershed, site, sep='/')
   path_list <- paste(file_path, list.files(file_path), sep= '/')
   data <- lapply(path_list, function(x) {
      dat <- read.table(x, skip = 0, header = TRUE, sep = ",", row.names = NULL, as.is = TRUE)
      # for each item in path list, grab the cap_rod number
      dat$rod_no <- unlist(strsplit(x, "_"))[8]
      return(dat)
   })
   combined.data <- do.call(rbind, data)
   combined.data <- combined.data %>%
      mutate(datetime = lubridate::mdy_hm(datetime))%>%
      distinct()%>%
      arrange(datetime)
   return(combined.data)
}
```

```{r}
interfiles <- 'formatted_data/stage_caprod'
year <- 2022
watershed <- 'lexen'
site <- 'lexen1'

stage_raw <- opn_concat(interfiles, year, watershed, site)

stage_raw <- stage_raw%>%
  set_names(c('ID','datetime','water_temp', 'wtr_ht_pt', 'wtr_ht_avg', 'rod_no'))

```


```{r}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+geom_line()

```

###Create complete timeseries that includes any missing datetimes
```{r}
#check if collection interval is consistent in dataset. Code as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw %>%
  mutate(datetime = round_date(datetime,
                               as.period(ts_interval))) %>%
  drop_na()
  

#create full timeseries 
full_ts <- tibble(datetime = seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))

stage_raw <- full_join(full_ts,stage_raw)


#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt))%>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature, battery for quick checks
2) Add ID column to use for identifying bad data
3) Plot raw data with flag if raw level changes by more than x%. 

```{r}
#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

#check battery (FEF caprods may not have battery log)
#DyBatt()

#add new ID column to ensure unique ID for each datetime
stage_raw_prep <- stage_raw%>%
  dplyr::select(-ID)%>% #remove ID column from raw data
  arrange(datetime)%>%
  rowid_to_column(var='ID')

#Raw stage plot
DyRawStage(df=stage_raw_prep,threshold = 0.2, flag='TRUE')
```


```{r}
bad_id <- c(7919:7932,9061:9065, 11072:11076, 12969:12972, 13960:13967, 16156:16160) # 

```


```{r}
#turn bad data points into NAs

vert_correction<- data.frame(ID = c(1:3), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw_prep,maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

stageAdj$site<- site
stageAdj$watershed <-watershed
```


```{r}
#plot adjusted stage
dyStageAdj(df=stage_adj)

```

# look at the adjusted values only
```{r}
dyStageAdjonly<- function(df= stageAdj,max=400){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(-150, max))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #        hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)
```


###Convert stage value to depth using initial position of capacitance rod

```{r}
# load manual measurements
# interfiles <- 'formatted_data/discharge/formatted_manual_measurements'
# file_path <- paste(getwd(),interfiles,paste(site,'.csv', sep = ""), sep='/')
# 
# manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)
# 
# manMeas<- read.csv(file_path)%>%
#       #timezone set to MST, change if loggers used MDT/MST
#       mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
#       mutate(water_depth=dep_to_bed-dep_to_water)%>%
#       mutate(staff = as.numeric(staff))
```
 
```{r}
# #choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
# stat_to_bed <- manMeas%>%
#   summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
#   pull(mean_dep_to_bed)
# 
# manMeas_fil <- manMeas %>%
#       #filter(watershed == watershed)%>%
#       #filter(site == site)%>%
#       dplyr::rename(., wtr_depth_not_static = water_depth) %>%
#       mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
### 10 to convert mm to cm

depth_offset <- 0
# depth_offset <- manMeas_fil %>%
#   slice_min(datetime)%>%
#   left_join(stage_adj%>%
#               dplyr::select(datetime, adj_wtr_ht))%>%
#   mutate(depth_offset= man_wtr_dep_static-adj_wtr_ht)%>%
#   pull(depth_offset)
```


```{r}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
manual_offset<- 0
# lexen1 = 0
# lexen2 = 0
stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)

stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

###compare cleaned water level to manual measurements
```{r}
#plot difference between measured water depth and manual depth measurement
stageAdj.man<- left_join(manMeas_fil,stage_adj)%>%
      mutate(diff = man_wtr_dep_static-wtr_depth)

ggplot(stageAdj.man, aes(datetime, diff))+
  geom_point(size=3)+
  theme_minimal()
```


```{r}
#plot water level time series with manual measurements as points
stage_check_plot<- stage_adj%>%
  left_join(manMeas_fil)%>%
  ggplot(aes(datetime,wtr_depth))+
    geom_line()+
    geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')

ggplotly(stage_check_plot)
```

###save
```{r}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```

```{r}

```

