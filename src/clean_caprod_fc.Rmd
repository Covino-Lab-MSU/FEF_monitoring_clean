---
title: "Cap Rod Cleaning - Fool Creek "
author: "Adapted for FEF by LKremer"
date: `r Sys.Date()`
output: html_document
editor_options: 
  chunk_output_type: console
---

Script for cleaning water level data from TruTrak capacitance rods. 
Designed for surface water level measurements.
Cleaning and QA/QC steps include 

1) removing bad data
2) adjusting data for shifts in logger position
3) converting stage to water depth
4) checking results against manual measurements.

Requires capacitance rod raw data and manual measurement spreadsheet

#Setup

```{r, include=FALSE}

pkgTest <- function(x)
{
  if (x %in% rownames(installed.packages()) == FALSE) {
    install.packages(x, dependencies= TRUE)
  }
  library(x, character.only = TRUE)
}

# Make a vector of the packages you need
neededPackages <- c('tidyverse', 'lubridate', 'xts', 'dygraphs', 'ggrepel','knitr', 'plotly') #tools for plot titles 

# For every package in the vector, apply your pkgTest function
for (package in neededPackages){pkgTest(package)}

source('./functions/stageFunctions.R') #load helper functions
```

#Clean By Site

###Load data with opn_concat
## requires same date format across all spreadsheets. I've been adding
the column formatted_dataetime in excel with:
 1. for dd/mm/yyyy hh:mm:ss '=REPLACE(MID(B2,4,20),4,0,LEFT(B2,3))+0'
 2. for d/m/yy hh:mm '=TEXT(VALUE(B2),"dd/mm/yyyy hh:mm")'


## 2020 clean

```{r functions, include=FALSE}
opn_concat <- function(interfiles, year, watershed, site) {
   file_path <- paste(getwd(), interfiles, year, watershed, site, sep='/')
   path_list <- paste(file_path, list.files(file_path), sep= '/')
   data <- lapply(path_list, function(x) {
      dat <- read.table(x, skip = 0, header = TRUE, sep = ",", row.names = NULL, as.is = TRUE)
      # for each item in path list, grab the cap_rod number
      dat$rod_no <- unlist(strsplit(unlist(strsplit(path_list[1], "_"))[8], "[.]"))[1]
      return(dat)
   })
   drops <- c('sample')
   combined.data <- do.call(rbind, data)
   combined.data <- combined.data %>%
      mutate(datetime = lubridate::mdy_hms(datetime))%>%
      select(-one_of(drops))%>%
      distinct()%>%
      arrange(datetime)
   return(combined.data)
}
```


## 2020 - Fool1 clean 


```{r importfc1, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc1'

stage_raw <- opn_concat(interfiles, year, watershed, site)

stage_raw <- stage_raw %>%
  dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%
  rowid_to_column(var='ID')

```

```{r rawpltfc1}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "water height point")

```

###Create complete timeseries that includes any missing datetimes
```{r checktimefc1}
#check if collection interval is consistent in dataset. Code as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)


#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature for quick checks
2) Plot raw data with flag if raw level changes by more than 2%. 

```{r chktempfc1}
#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'
```

```{r plantflagsfc1}
#Raw stage plot
DyRawStage(df=stage_raw,threshold = 0.2, flag='TRUE')
```

3) Manually identify points to be removed or corrected using the flagged plot
```{r badidfc1}
#fool1
bad_id_fc1_2020 <- c(977:981, 5050:5053, 10953:10957)

#fool1
vert_correction_fc1_2020 <- data.frame(ID = c(8175:8176), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))
  
bad_id <- bad_id_fc1_2020

```


```{r correctfc1}
#turn bad data points into NAs

vert_correction<- data.frame(ID = c(0:1), offset=c(0.00))%>%
  mutate(cumOffset = cumsum(offset))

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw,maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID > 3) %>% # beginning of stream data
    filter(ID < 16405) %>% # end of stream data
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

#stageAdj$site<- site
#stageAdj$watershed<-watershed
```


```{r plot2fc1}
#plot adjusted stage
dyStageAdj(df=stage_adj)

```

# look at the adjusted values only
```{r plot3fc1}
dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

simplefc1 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```


```{r exportfc1}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```



## 2020 - Fool2 clean 


```{r importfc2, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc2'

stage_raw <- opn_concat(interfiles, year, watershed, site)

stage_raw <- stage_raw %>%
  dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%
  rowid_to_column(var='ID')

```

```{r plot1fc2}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "water height point")

```

###Create complete timeseries that includes any missing datetimes
```{r checktimefc2}
#check if collection interval is consistent in dataset. Code as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature, battery for quick checks
2) Add ID column to use for identifying bad data
3) Plot raw data with flag if raw level changes by more than x%. 

```{r chktempfc2}
#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'
```


```{r plantflagsfc2}
#Raw stage plot
DyRawStage(df=stage_raw, threshold = 0.2, flag='TRUE')
```


```{r badidfc2}
#fool2
bad_id_fc2_2020 <- c(4953:4960, 11952:12730)

vert_correction_fc2_2020 <- data.frame(ID = c(1:2), offset=c(0.00)) %>%
  mutate(cumOffset = cumsum(offset))

bad_id <- bad_id_fc2_2020
```

```{r vertcorrectfc2}
#turn bad data points into NAs
vert_correction <- vert_correction_fc2_2020

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

#stageAdj$site<- site
#stageAdj$watershed<-watershed
```


```{r plot2fc2}
#plot adjusted stage
dyStageAdj(df=stage_adj)

```

# look at the adjusted values only
```{r plot3fc2}
dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

simplefc2 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```

```{r exportfc2}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```


## 2020 - Fool3 clean 


```{r importfc3, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc3'

stage_raw <- opn_concat(interfiles, year, watershed, site)

stage_raw <- stage_raw %>%
  dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%
  rowid_to_column(var='ID')

```

```{r plot1fc3}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "water height point")

```

###Create complete timeseries that includes any missing datetimes
```{r checktimefc3}
#check if collection interval is consistent in dataset. Code as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature, battery for quick checks
2) Add ID column to use for identifying bad data
3) Plot raw data with flag if raw level changes by more than x%. 

```{r chktempfc3}
#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'
```


```{r plantflagsfc3}
#Raw stage plot
DyRawStage(df=stage_raw, threshold = 0.2, flag='TRUE')
```


```{r badidfc3}
#fool3
bad_id_fc3_2020 <- c(5182:5186, 12210:12965)

vert_correction_f3_2020 <- data.frame(ID = c(7860:12965), offset=c(20)) %>%
  mutate(cumOffset = offset)

bad_id <- bad_id_fc3_2020
```

```{r vertcorrectfc3}
#turn bad data points into NAs
vert_correction<- vert_correction_f3_2020

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df = stage_raw, maxgap = 8) %>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg < -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

#stageAdj<- AdjStage(maxgap=30)

#stageAdj$site<- site
#stageAdj$watershed<-watershed
```


```{r plot2fc3}
#plot adjusted stage
dyStageAdj(df=stage_adj)

```

# look at the adjusted values only
```{r plot3fc3}

dyStageAdjonly<- function(df= stageAdj, max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0,300)) %>%
            dyAxis('y2',label='ID',independentTicks=T) %>%
            dySeries('ID',axis='y2') %>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2) %>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

simplefc3 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```

```{r exportfc3}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```


## 2020 - Fool4 clean 


```{r importfc4, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2020
watershed<- 'fool'
site <- 'fc4'

stage_raw <- opn_concat(interfiles, year, watershed, site)

stage_raw <- stage_raw %>%
  dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%
  rowid_to_column(var='ID')

```

```{r plot1fc4}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line() +
  labs(title=site,
        x ="Date", y = "water height point")
  
```

###Create complete timeseries that includes any missing datetimes
```{r checktimefc4}
#check if collection interval is consistent in dataset. Code as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)

#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature, battery for quick checks
2) Add ID column to use for identifying bad data
3) Plot raw data with flag if raw level changes by more than x%. 

```{r chktempfc4}
#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'
```


```{r plantflagsfc4}
#Raw stage plot
DyRawStage(df=stage_raw, threshold = 0.2, flag='TRUE')
```


```{r badidfc4}
#fool4
bad_id_fc4_2020 <- c(5182:5186, 5909:5912)

vert_correction_f4_2020 <- data.frame(ID = c(7860:12965), offset=c(0.00)) %>%
  mutate(cumOffset = cumsum(offset))

bad_id <- bad_id_fc4_2020
```


```{r vertcorrectfc4}
#turn bad data points into NAs
vert_correction<- vert_correction_f4_2020

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw, maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    filter(ID < 12968) %>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

#stageAdj$site<- site
#stageAdj$watershed<-watershed
```


```{r plot2fc4}
#plot adjusted stage
dyStageAdj(df=stage_adj)

```

# look at the adjusted values only
```{r plot3fc4}
dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)

simplefc4 <- stage_adj %>%
  select(datetime, adj_wtr_ht, site) %>%
  drop_na()
```

```{r exportfc4}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```

# 2020
# For a further check, plot and stack all sites
```{r}
allfc <- rbind(simplefc1,simplefc2) 
allfc <- rbind(allfc,simplefc3) 
allfc <- rbind(allfc,simplefc4)

ggplot(allfc, aes(x = datetime, y = adj_wtr_ht, color = site)) +  
  geom_line()
```



#fool3
bad_id_fc3_2020 <- c(0:5, 1166:1169, 4283:4286, 10091:10094)

#fool3 (Jul17 12:00 - 5624: Sept16 12:00 - 14408 -> 19)
vert_correction_fc3_2020 <- data.frame(ID = c(5624:14408),offset=c(-0.0025))%>%
  mutate(cumOffset = cumsum(offset))
  
#fool4
bad_id_fc4_2020 <- c(0:4, 3900:3905, 8965:8969, 10967:10970, 15117:15121)

#29 June 18:00 1771
vert_correction_fc4_2020 <- data.frame(ID = c(5083:15116), offset=c(0.0005))%>%
  mutate(cumOffset = cumsum(offset))






## 2021 clean 
```{r functions, include=FALSE}
opn_concat <- function(interfiles, year, watershed, site) {
   file_path <- paste(getwd(), interfiles, year, watershed, site, sep='/')
   path_list <- paste(file_path, list.files(file_path), sep= '/')
   data <- lapply(path_list, function(x) {
      dat <- read.table(x, skip = 0, header = TRUE, sep = ",", row.names = NULL, as.is = TRUE)
      # for each item in path list, grab the cap_rod number
      dat$rod_no <- unlist(strsplit(unlist(strsplit(path_list[1], "_"))[8], "[.]"))[1]
      return(dat)
   })
   drops <- c("formatted_datetime", 'ID')
   combined.data <- do.call(rbind, data)
   combined.data <- combined.data %>%
      mutate(datetime = lubridate::mdy_hm(datetime))%>%
      select(-one_of(drops))%>%
      distinct()%>%
      arrange(datetime)
   return(combined.data)
}
```






## No 2020 data for lexen
```{r import1, include=FALSE}
interfiles <- 'formatted_data/stage_caprod'
year <- 2021
watershed<- 'fool'
site <- 'fc1'

stage_raw <- opn_concat(interfiles, year, watershed, site)

stage_raw <- stage_raw %>%
  dplyr::rename(., wtr_ht_pt = wtrhgt__2, wtr_ht_avg = wtrhgt__3, water_temp = wtemp_a_1) %>%
  rowid_to_column(var='ID')

```


```{r plot1}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+
  geom_line()

```

###Create complete timeseries that includes any missing datetimes
```{r checktime}
#check if collection interval is consistent in dataset. Code as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw%>%
  mutate(datetime = round_date(datetime, as.period(ts_interval)))

#create full timeseries 
full_ts <- tibble(datetime=seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))
stage_raw <- full_join(full_ts,stage_raw)


#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt)) %>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature, battery for quick checks
2) Add ID column to use for identifying bad data
3) Plot raw data with flag if raw level changes by more than x%. 

```{r plantflags}
#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

#check battery (FEF caprods may not have battery log)
#DyBatt()

#add new ID column to ensure unique ID for each datetime
stage_raw_prep <- stage_raw%>%
  dplyr::select(-ID)%>% #remove ID column from raw data
  arrange(datetime)%>%
  rowid_to_column(var='ID')

#Raw stage plot
DyRawStage(df=stage_raw_prep,threshold = 0.2, flag='TRUE')
```

#fool1
bad_id <- c(0:289, 1895:1898, 2910:2914, 4053:4056, 4944:4948, 8099:8103, 14991:14994, 18129:18132)

#fool1
vert_correction<- data.frame(ID = c(8175:8176), offset=c(4))%>%
  mutate(cumOffset = cumsum(offset))
  
#fool2
bad_id <- c(0:219,1174:1178, 4288:4293, 11104:11107, 16256:16257)

#fool2 (Jul8 16:00 - 1454: Sept1 1:00 - 12916 -> 10/)
vert_correction<- data.frame(ID = c(1454:12916), offset=c(-0.0015))%>%
  mutate(cumOffset = cumsum(offset))
#-0.0008724

#fool3
bad_id <- c(0:5, 1166:1169, 4283:4286, 10091:10094)

#fool3 (Jul17 12:00 - 5624: Sept16 12:00 - 14408 -> 19)
vert_correction<- data.frame(ID = c(5624:14408),offset=c(-0.0025))%>%
  mutate(cumOffset = cumsum(offset))
  
#fool4
bad_id <- c(0:4, 3900:3905, 8965:8969, 10967:10970, 15117:15121)

#29 June 18:00 1771
vert_correction<- data.frame(ID = c(5083:15116), offset=c(0.0005))%>%
  mutate(cumOffset = cumsum(offset))
  


```{r badid}
bad_id <- c(1:150, 1177:1183, 2003:2008, 2892:2897, 4011:4018, 4917:4922, 7077:7080, 8063:8068, 15125:15129)

# no vert corrections for dh
```


```{r vertcorrect}
#turn bad data points into NAs
#lexen1
# jun16 12:00 5075 - oct6 8:30-21184 -> 25
vert_correction<- data.frame(ID = c(5075:21184), offset=c(0.002))%>%
  mutate(cumOffset = cumsum(offset))

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw_prep,maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

#stageAdj$site<- site
#stageAdj$watershed<-watershed
```


```{r plot2}
#plot adjusted stage
dyStageAdj(df=stage_adj)

```

# look at the adjusted values only
```{r plot3}
dyStageAdjonly<- function(df= stageAdj,max=1200){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(0, 300))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #       hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)
```

## Check manual measurements
```{r importmanual}
# load manual measurements
interfiles <- 'formatted_data/discharge/formatted_manual_measurements'
file_path <- paste(getwd(),interfiles,paste(site,'.csv', sep = ""), sep='/')

manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)

manMeas<- read.csv(file_path)%>%
      #timezone set to MST, change if loggers used MDT/MST
      mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
      mutate(water_depth=dep_to_bed-dep_to_water)%>%
      mutate(staff = as.numeric(staff))
```


```{r depthoffset}
#choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
stat_to_bed <- manMeas%>%
  summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
  pull(mean_dep_to_bed)

manMeas_fil <- manMeas %>%
      #filter(watershed == watershed)%>%
      #filter(site == site)%>%
      dplyr::rename(., wtr_depth_not_static = water_depth) %>%
      mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
### 10 to convert mm to cm

depth_offset <- manMeas_fil %>%
  slice_min(datetime)%>%
  left_join(stage_adj%>%
              dplyr::select(datetime, adj_wtr_ht))%>%
  mutate(depth_offset= man_wtr_dep_static-adj_wtr_ht)%>%
  pull(depth_offset)
```


```{r wtrdepth}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
manual_offset<- 0
# lexen1 = 
# lexen2 = 0
stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)

stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

###compare cleaned water level to manual measurements
```{r plot4}
#plot difference between measured water depth and manual depth measurement
stageAdj.man<- left_join(manMeas_fil,stage_adj)%>%
      mutate(diff = man_wtr_dep_static-wtr_depth)

ggplot(stageAdj.man, aes(datetime, diff))+
  geom_point(size=3)+
  theme_minimal()
```


```{r plot5}
#plot water level time series with manual measurements as points
stage_check_plot<- stage_adj%>%
  left_join(manMeas_fil)%>%
  ggplot(aes(datetime,wtr_depth))+
    geom_line()+
    geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')

ggplotly(stage_check_plot)
```

###save
```{r save2021}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))

```








## 2022 clean 
```{r}
opn_concat <- function(interfiles, year, watershed, site) {
   file_path <- paste(getwd(), interfiles, year, watershed, site, sep='/')
   path_list <- paste(file_path, list.files(file_path), sep= '/')
   data <- lapply(path_list, function(x) {
      dat <- read.table(x, skip = 0, header = TRUE, sep = ",", row.names = NULL, as.is = TRUE)
      # for each item in path list, grab the cap_rod number
      dat$rod_no <- unlist(strsplit(x, "_"))[8]
      return(dat)
   })
   combined.data <- do.call(rbind, data)
   combined.data <- combined.data %>%
      mutate(datetime = lubridate::mdy_hm(datetime))%>%
      distinct()%>%
      arrange(datetime)
   return(combined.data)
}
```

```{r}
interfiles <- 'formatted_data/stage_caprod'
year <- 2022
watershed <- 'lexen'
site <- 'lexen1'

stage_raw <- opn_concat(interfiles, year, watershed, site)

stage_raw <- stage_raw%>%
  set_names(c('ID','datetime','water_temp', 'wtr_ht_pt', 'wtr_ht_avg', 'rod_no'))

```


```{r}
#quick plot of stage

ggplot(stage_raw, aes(datetime,wtr_ht_pt))+geom_line()

```

###Create complete timeseries that includes any missing datetimes
```{r}
#check if collection interval is consistent in dataset. Code as written only handles one interval but can be modified if interval was changed. 
checkTimeSteps()

ts_interval<- stage_raw$datetime[2] - stage_raw$datetime[1]

##round datetime to nearest whole interval
stage_raw <- stage_raw %>%
  mutate(datetime = round_date(datetime,
                               as.period(ts_interval))) %>%
  drop_na()
  

#create full timeseries 
full_ts <- tibble(datetime = seq.POSIXt(stage_raw$datetime[1], stage_raw$datetime[length(stage_raw$datetime)], by=ts_interval))

stage_raw <- full_join(full_ts,stage_raw)


#identify missing timesteps:
miss_ts <- filter(stage_raw, is.na(wtr_ht_pt))%>%
  pull(datetime)
length(miss_ts)
```

###Clean Raw Stage

1) Plot temperature, battery for quick checks
2) Add ID column to use for identifying bad data
3) Plot raw data with flag if raw level changes by more than x%. 

```{r}
#check temp data
DyTemp(airtemp = 'n') #check function if have logger_temp, default is 'y'

#check battery (FEF caprods may not have battery log)
#DyBatt()

#add new ID column to ensure unique ID for each datetime
stage_raw_prep <- stage_raw%>%
  dplyr::select(-ID)%>% #remove ID column from raw data
  arrange(datetime)%>%
  rowid_to_column(var='ID')

#Raw stage plot
DyRawStage(df=stage_raw_prep,threshold = 0.2, flag='TRUE')
```


```{r}
bad_id <- c(7919:7932,9061:9065, 11072:11076, 12969:12972, 13960:13967, 16156:16160) # 

```


```{r}
#turn bad data points into NAs

vert_correction<- data.frame(ID = c(1:3), offset=c(0))%>%
  mutate(cumOffset = cumsum(offset))

#function to make vertical correction and interpolate between missing values 
stage_adj<- AdjStage(df= stage_raw_prep,maxgap=8)%>%
    mutate(watershed = watershed)%>%
    mutate(site = site)%>%
    mutate(level_flag = ifelse(wtr_ht_avg< -50, 'Below Logger',
    ifelse(wtr_ht_avg> 1050, 'Over Logger', 'In Range')))

stageAdj<- AdjStage(maxgap=30)

stageAdj$site<- site
stageAdj$watershed <-watershed
```


```{r}
#plot adjusted stage
dyStageAdj(df=stage_adj)

```

# look at the adjusted values only
```{r}
dyStageAdjonly<- function(df= stageAdj,max=400){
      tsStageAdj<- xts(dplyr::select(df, datetime, adj_wtr_ht,ID), order.by=df$datetime)
      dygraph(tsStageAdj) %>% 
            dyAxis('y',label='mm',valueRange = c(-150, max))%>%
            dyAxis('y2',label='ID',independentTicks=T)%>%
            dySeries('ID',axis='y2')%>%
            dyRangeSelector() %>%
            #dyHighlight(highlightCircleSize = 4, 
            #        highlightSeriesBackgroundAlpha = 0.2,
            #        hideOnMouseOut = TRUE)%>%
            dyOptions(drawPoints = FALSE, pointSize = 2)%>%
            dyLegend(show = "always")
}

dyStageAdjonly(df=stage_adj)
```


###Convert stage value to depth using initial position of capacitance rod

```{r}
# load manual measurements
# interfiles <- 'formatted_data/discharge/formatted_manual_measurements'
# file_path <- paste(getwd(),interfiles,paste(site,'.csv', sep = ""), sep='/')
# 
# manMeas <- read.table(file_path, skip=0, header=TRUE, sep=",", row.names = NULL, as.is = TRUE)
# 
# manMeas<- read.csv(file_path)%>%
#       #timezone set to MST, change if loggers used MDT/MST
#       mutate(datetime = round_date(mdy_hm(datetime, tz='America/Phoenix'),'30 minutes'))%>% 
#       mutate(water_depth=dep_to_bed-dep_to_water)%>%
#       mutate(staff = as.numeric(staff))
```
 
```{r}
# #choose a static depth to bed value. Here we are using a mean of manual bed measurements from the top of the caprod post
# stat_to_bed <- manMeas%>%
#   summarize(mean_dep_to_bed = mean(dep_to_bed,na.rm=T))%>%
#   pull(mean_dep_to_bed)
# 
# manMeas_fil <- manMeas %>%
#       #filter(watershed == watershed)%>%
#       #filter(site == site)%>%
#       dplyr::rename(., wtr_depth_not_static = water_depth) %>%
#       mutate(man_wtr_dep_static = 10*(stat_to_bed - dep_to_water))
### 10 to convert mm to cm

depth_offset <- 0
# depth_offset <- manMeas_fil %>%
#   slice_min(datetime)%>%
#   left_join(stage_adj%>%
#               dplyr::select(datetime, adj_wtr_ht))%>%
#   mutate(depth_offset= man_wtr_dep_static-adj_wtr_ht)%>%
#   pull(depth_offset)
```


```{r}
#start with 0 value, change if plots below suggest need for manual adjustment change value. 
manual_offset<- 0
# lexen1 = 0
# lexen2 = 0
stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset + manual_offset)

stage_adj <- stage_adj%>%
  mutate(wtr_depth = adj_wtr_ht + depth_offset[1] + manual_offset)
```

###compare cleaned water level to manual measurements
```{r}
#plot difference between measured water depth and manual depth measurement
stageAdj.man<- left_join(manMeas_fil,stage_adj)%>%
      mutate(diff = man_wtr_dep_static-wtr_depth)

ggplot(stageAdj.man, aes(datetime, diff))+
  geom_point(size=3)+
  theme_minimal()
```


```{r}
#plot water level time series with manual measurements as points
stage_check_plot<- stage_adj%>%
  left_join(manMeas_fil)%>%
  ggplot(aes(datetime,wtr_depth))+
    geom_line()+
    geom_point(aes(datetime, man_wtr_dep_static),size=3,col='red')

ggplotly(stage_check_plot)
```

###save
```{r}
stage_final <- stage_adj %>%
      drop_na() %>%
      mutate(date = lubridate::date(datetime)) %>%
      mutate(time = format(datetime, format = "%H:%M")) %>%
      dplyr::select(watershed, site, date, time, wtr_depth, level_flag) 
    
loc_site<- paste(watershed,site, sep='_') 

interfiles <- 'clean_data/stage_caprod'
file_path <- paste(getwd(), interfiles,year,watershed,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
write_csv(stage_final, file=paste0(file_path, '/',site, '_clean.csv'))
```

```{r}

```

