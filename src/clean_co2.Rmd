---
title: "co2_clean"
author: "Lauren Kremer"
date: "11/21/2021"
output: html_document
---

Script for CO2 data from OM-CP-VOLT101A Voltage Data Logger

1) removing bad data
2) adjusting data for shifts 

Requires CO2 raw data


```{r setup, include=FALSE}

source('./functions/co2_DO_functions.R') #load helper functions
# package loading function
pkgTest <- function(x)
{
  if (x %in% rownames(installed.packages()) == FALSE) {
    install.packages(x, dependencies= TRUE)
  }
  library(x, character.only = TRUE)
}

# Make a vector of the packages you need
neededPackages <- c('tidyverse', 'lubridate', 'xts', 'dygraphs', 'ggrepel','knitr', 'plotly') #tools for plot titles 

# For every package in the vector, apply your pkgTest function
for (package in neededPackages){pkgTest(package)}
```


```{r, include=FALSE}
opn_concat_site_2022 <- function(interfiles, year, location, site) {
  file_path <- paste(getwd(),interfiles,year, location,site, sep='/')
  path_list <- paste(file_path, list.files(file_path), sep= '/')
  data <- lapply(path_list, function(x) {
    dat <- read.table(x, skip = 6, header = TRUE, sep = ",", row.names = NULL, as.is = TRUE)
    # for each item in path list, grab the device number
    #dat$logr_no <- unlist(strsplit(x, "_"))[9]
    return(dat)
  })
  combined.data <- do.call(rbind, data)
  combined.data <- combined.data %>%
    mutate(datetime = lubridate::mdy(Date) + hms(Time))%>%
    arrange(datetime)%>%
    distinct()%>%
  return(combined.data)
}
```
 
```{r, include = FALSE}
interfiles <- 'formatted_data/stream_co2'
# possible locations: 'dh', 'est_louis', 'fool', 'lexen'
year <- '2022'
location<- 'fc'

site<- 'fc1'
```

```{r,include = FALSE}

co2_raw <- opn_concat_site_2022(interfiles, year, location, site)

## This will convert a mV column to voltage.  For now, the statement will not delete the mV column, rather generate a mV column if V are provided. 

if(colnames(co2_raw[3]) == 'Voltage..mV.') {
  co2_raw$Voltage_V = Voltage..mV./1000;
  names(co2_raw)[names(co2_raw) == 'Voltage..mV.'] <- 'Voltage_mV'
} else 
  co2_raw$Voltage_mV = co2_raw$Voltage..V.*1000
  names(co2_raw)[names(co2_raw) == 'Voltage..V.'] <- 'Voltage_V'

```


```{r,include = FALSE}
#quick plot of voltage
co2_check_plot <- ggplot(co2_raw, aes(datetime,Voltage_V))+
  geom_line()

ggplotly(co2_check_plot)
```

Convert voltage to CO2:

CO2ppm= (XFâˆ’XZ)*V/Vmax +XZ 

where V is the measured voltage, XF is the full scale value for CO2 output XZ is the zero value, Vmax is the full scale DAC output 

Measurement range of the Vaisala sensor 0 - 10 000 ppm CO2

Voltage recorders have different ranges, some with +-3V DC, others with +-160mV DC (0.32V range)

160mV multiplier = high voltage ppm (10,000) / voltage range (160mV) = 62.5 ppm/mV = 62500 ppm/V
=((mV/1000)/3)*10000

3V multiplier = high voltage ppm (10,000) / voltage range (3V) = 3333.33 ppm/V 

*******MORE ON THIS LATER, FOR NOW (15 JUNE 2022), USING A CONVERSION OF MV TO V IF NEEDED, AND CALCULATING THE MULTIPLIER BASED ON A 3V DATALOGGER. 160MV MULTIPLIER AS ABOVE GIVES PPMS ~5000.
```{r,include = FALSE}

co2_raw$co2_ppm <- (co2_raw$Voltage_V/3)*10000


co2_check_plot <- ggplot(co2_raw, aes(datetime,co2_ppm))+
  geom_line()

ggplotly(co2_check_plot)
```

To review raw data across watersheds and years, lets pull in all data
and merge them into one dataset so we can plot with subsets and 'facet'
We can pretty easily do this with 'recursive = True' in our list.files function

Because the .csvs were formatted differently between years, the function for each year
will be slightly different (see functions.R)
```{r, include = FALSE}

conv_function <- function(x) {
  if ("Voltage..mV." %in% names(x)) {
    Voltage..V. <- x$Voltage..mV./1000;
    x <- cbind(x, Voltage..V.)
  } else if ("Voltage..V." %in% names(x)) {
    Voltage..mV. <- x$Voltage..V.*1000;
    x <- cbind(x, Voltage..mV.)
  }
}

opn_concat_all_2022 <- function(interfiles, year) {
  file_path <- paste(getwd(), interfiles, year, sep='/')
  path_list <- paste(file_path, list.files(file_path, pattern = ".csv$", recursive = TRUE), sep = '/') 
  data <- lapply(path_list, function(x) {
    dat <- read.table(x, skip = 6, header = TRUE, sep = ",", row.names = NULL, as.is = TRUE)
    dat$year <- unlist(strsplit(x, "/"))[9]
    dat$shed <- unlist(strsplit(x, "/"))[10]
    dat$site <-unlist(strsplit(unlist(strsplit(x, "/"))[11], "_"))[1]
    # for each item in path list, grab the device number
    #dat$logr_no <- unlist(strsplit(x, "_"))[9]
    return(dat)
  })
  conv_data <- lapply(data, conv_function)
  #conv_data <-lapply(conv_data, conv_data[ , order(names(conv_data))])
  combined.data <- do.call(rbind, conv_data)
  combined.data <- combined.data %>%
    mutate(datetime = lubridate::mdy(Date) + hms(Time))%>%
    distinct()%>%
    arrange(shed, site, datetime)%>%
  return(combined.data)
}
```

```{r}
co2_2022 <- opn_concat_all_2022(interfiles, year)

co2_2022$co2_ppm <- (co2_2022$Voltage..V./3)*10000
```






```{r, include = FALSE}
interfiles <- 'formatted_data/stream_co2'
# possible locations: 'dh', 'est_louis', 'fool', 'lexen'
year <- '2021'
location<- 'fc'

site<- 'fc1'
```

###Create complete timeseries that includes any missing datetimes
```{r,include = FALSE}
# #check if collection interval is consistent in dataset. Code as written only handles one interval but can be modified if interval was changed. 
# checkTimeSteps()
# 
# ts_interval<- co2_raw$datetime[2] - co2_raw$datetime[1]
# 
# ##round datetime to nearest whole interval
# co2_raw <- co2_raw%>%
#   mutate(datetime = round_date(datetime, as.period(ts_interval)))
# 
# #create full timeseries 
# full_ts <- tibble(datetime=seq.POSIXt(co2_raw$datetime[1], co2_raw$datetime[length(co2_raw$datetime)], by=ts_interval))
# co2_raw <- full_join(full_ts,co2_raw)
# 
# 
# #identify missing timesteps:
# miss_ts <- filter(co2_raw, is.na(co2_ppm))%>%
#   pull(datetime)
# length(miss_ts)
```


###save
```{r}
#co2_raw$datetime <- format(co2_raw$datetime, usetz=TRUE)

#interfiles <- '3_cleaned'
#file_path <- paste(getwd(),interfiles,location,site, sep='/')
#saveRDS(stage_final, file=paste0('data/cln/wtr_lvl_',loc_site,'.csv'))
#write_csv(co2_raw, file=paste0(file_path, '_clean.csv'))


```


```{r, include=FALSE}
opn_cleaned <- function(interfiles, location) {
  file_path <- paste(getwd(),interfiles,location, sep='/')
  path_list <- paste(file_path, list.files(file_path), sep= '/')
   data <- lapply(path_list, function(x) {
     dat <- read.table(x, skip = 0, header = TRUE, sep = ",", row.names = NULL, as.is = TRUE)
     # for each item in path list, grab the site nname
     sitecsv <- unlist(strsplit(x, "/"))[12]
     dat$site <- unlist(strsplit(sitecsv, "_"))[1]
     return(dat)
   })
   combined.data <- do.call(rbind, data)
   #drops <- c("formatted_datetime")
   combined.data <- combined.data %>%
     #mutate(datetime = strptime(datetime, format = '%Y-%m-%dT%H:%M:%OS%z'))%>%
     mutate(datetime = lubridate::as_datetime(datetime))%>%
     arrange(site)%>%
     #select(-one_of(drops))%>%
     #distinct()%>%
     return(combined.data)
 }

```

```{r}
interfiles <- '3_cleaned'
# # possible locations: 'dh', 'est_louis', 'fool', 'lexen'
location <- 'fool'
co2_cleaned <- opn_cleaned(interfiles, location)
# 
str(co2_cleaned)
# 
co2_cleaned <- subset(co2_cleaned, datetime <= '2021-07-23 20:00:00')
                      
```

```{r}
# co2plot <- ggplot(data = co2_cleaned, aes(x=datetime, y=co2_ppm, color = site)) + 
#   geom_line() + 
#   xlab('Date') +
#   ylab('CO2 (ppm)') 
# 
# 
# 
# ggplotly(co2plot)
```


